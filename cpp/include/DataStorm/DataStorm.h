// **********************************************************************
//
// Copyright (c) 2018-present ZeroC, Inc. All rights reserved.
//
// **********************************************************************

#pragma once

#include <DataStorm/Config.h>

#include <Ice/Ice.h>

#include <DataStorm/Types.h>
#include <DataStorm/Sample.h>
#include <DataStorm/Node.h>
#include <DataStorm/InternalI.h>
#include <DataStorm/InternalT.h>

#include <regex>

/**
 * \mainpage %DataStorm API Reference
 *
 * \section namespaces Namespaces
 *
 * @ref DataStorm â€” The %DataStorm core library.
 */
namespace DataStorm
{

template<typename, typename, typename> class Reader;
template<typename, typename, typename> class Writer;
template<typename, typename, typename> class KeyReader;
template<typename, typename, typename> class KeyWriter;
template<typename, typename, typename> class FilteredKeyReader;

/**
 * A sample provides information about a data element update.
 *
 * The Sample template provides access to the key, value as well
 * as additional information such as the event, timestamp, update
 * tag. Samples are generated and published by writers and
 * received by readers.
 */
template<typename Key, typename Value, typename UpdateTag=std::string> class Sample
{
public:

    /**
     * The type of the sample key.
     */
    using KeyType = Key;

    /**
     * The type of the sample value.
     */
    using ValueType = Value;

    /**
     * The type of the update tag. The update tag type defaults to string if it's
     * not explicitly specified with the Sample template paremeters.
     */
    using UpdateTagType = UpdateTag;

    /**
     * An element ID identifies the origin of a sample. The tuple first element
     * is the session ID, the second element is the peer topic opaque ID and
     * the third is the peer data reader or writer opaque ID.
     **/
    using ElementId = std::tuple<std::string, long long int, long long int>;

    /**
     * The event associated with the sample.
     *
     * @return The sample event.
     */
    SampleEvent getEvent() const;

    /**
     * The key of the sample.
     *
     * @return The sample key.
     */
    const Key& getKey() const;

    /**
     * The value of the sample.
     *
     * Depending on the sample event, the sample value might not always be
     * available. It's the case if the sample event is Remove where this
     * method will return a default value.
     *
     * @return The sample value.
     */
    const Value& getValue() const;

    /**
     * The update tag for the partial update.
     *
     * This method should only be called if the sample event is PartialUpdate.
     *
     * @return The update tag.
     */
    UpdateTag getUpdateTag() const;

    /**
     * The timestamp of the sample.
     *
     * The timestamp is generated by the writer and corresponds to the time of
     * sending.
     *
     * @return The timestamp.
     */
    std::chrono::time_point<std::chrono::system_clock> getTimeStamp() const;

    /**
     * The origin of the sample.
     *
     * The origin of the sample identifies uniquely on the node the writer
     * that created the sample. It's a tupple composed of the node session
     * identity, the topic and writer opaque identifiers.
     *
     * @return The tuple that uniquely identifies the origin of the sample
     *         on the node.
     */
    ElementId getOrigin() const;

    /** @private */
    Sample(const std::shared_ptr<DataStormI::Sample>&);

private:

    std::shared_ptr<DataStormI::SampleT<Key, Value, UpdateTag>> _impl;
};

/**
 * Convert the given sample type to a string and add it to the stream.
 *
 * @param os The output stream
 * @param sampleType The sample type to add to the stream
 * @return The output stream
 */
std::ostream&
operator<<(std::ostream& os, SampleEvent sampleType)
{
    switch(sampleType)
    {
    case SampleEvent::Add:
        os << "Add";
        break;
    case SampleEvent::Update:
        os << "Update";
        break;
    case SampleEvent::Remove:
        os << "Remove";
        break;
    case SampleEvent::PartialUpdate:
        os << "PartialUpdate";
        break;
    default:
        os << static_cast<int>(sampleType);
        break;
    }
    return os;
}

/**
 * Convert the given sample type vector to a string and add it to the stream.
 *
 * @param os The output stream
 * @param types The sample type vector to add to the stream
 * @return The output stream
 */
std::ostream&
operator<<(std::ostream& os, const std::vector<SampleEvent>& types)
{
    os << "[";
    for(auto p = types.begin(); p != types.end(); ++p)
    {
        if(p != types.begin())
        {
            os << ',';
        }
        os << *p;
    }
    os << "]";
    return os;
}

/**
 * Convert the given sample to a string and add it to the stream. The implementation
 * outputs the sample value.
 *
 * @param os The output stream
 * @param sample The sample to add to the stream
 * @return The output stream
 */
template<typename K, typename V, typename U>
std::ostream&
operator<<(std::ostream& os, const Sample<K, V, U>& sample)
{
    os << sample.getValue();
    return os;
}

/**
 * The Topic class.
 *
 * This class allows constructing reader and writer objects. It's also
 * used to setup filter and updater functions.
 *
 */
template<typename Key, typename Value, typename UpdateTag=std::string>
class Topic
{
public:

    /**
     * The topic's key type.
     */
    using KeyType = Key;

    /**
     * The topic's value type.
     */
    using ValueType = Value;

    /**
     * The topic's update tag type (defaults to std::string if not specified).
     */
    using UpdateTagType = UpdateTag;

    /**
     * The topic's writer type.
     */
    using WriterType = Writer<Key, Value, UpdateTag>;

    /**
     * The topic's reader type.
     */
    using ReaderType = Reader<Key, Value, UpdateTag>;

    /**
     * The reader identifier type. The tuple first element is the session ID,
     * the second element is the peer topic opaque ID and the third is the
     * peer data reader opaque ID.
     */
    using ReaderId = std::tuple<std::string, long long int, long long int>;

    /**
     * The writer identifier type. The tuple first element is the session ID,
     * the second element is the peer topic opaque ID and the third is the
     * peer data writer opaque ID.
     */
    using WriterId = std::tuple<std::string, long long int, long long int>;

    /**
     * Construct a new Topic for the topic with the given name.
     *
     * @param node The node.
     * @param name The name of the topic.
     */
    Topic(const Node&, const std::string&);

    /**
     * Construct a new Topic by taking ownership of the given topic.
     *
     * @param topic The topic to transfer ownership from.
     */
    Topic(Topic&&);

    /**
     * Destruct the Topic. This disconnects the topic from peers.
     */
    ~Topic();

    /**
     * Move assignement operator.
     *
     * @param topic The topic.
     **/
    Topic& operator=(Topic&&);

    /**
     * Indicates whether or not data writers are online.
     *
     * @return True if data writers are connected, false otherwise.
     */
    bool hasWriters() const;

    /**
     * Wait for given number of data writers to be online.
     *
     * @param count The number of date writers to wait.
     */
    void waitForWriters(unsigned int = 1) const;

    /**
     * Wait for data writers to be offline.
     */
    void waitForNoWriters() const;

    /**
     * Set the default configuration used to construct readers.
     *
     * @param config The default writer configuration.
     */
    void setWriterDefaultConfig(const WriterConfig&);

    /**
     * Indicates whether or not data readers are online.
     *
     * @return True if data readers are connected, false otherwise.
     */
    bool hasReaders() const;

    /**
     * Wait for given number of data readers to be online.
     *
     * @param count The number of data readers to wait.
     */
    void waitForReaders(unsigned int = 1) const;

    /**
     * Wait for data readers to be offline.
     */
    void waitForNoReaders() const;

    /**
     * Set the default configuration used to construct readers.
     *
     * @param config The default reader configuration.
     */
    void setReaderDefaultConfig(const ReaderConfig&);

    /**
     * Set an updater function for the given update tag. The function is called
     * when a partial update is received or sent to compute the new value. The
     * function is provided the latest value and the partial update. It should
     * return the new value.
     *
     * @param tag The update tag.
     * @param updater The updater function.
     */
    template<typename UpdateValue>
    void setUpdater(const UpdateTag&, std::function<void (Value&, UpdateValue)>);

    /**
     * Set a key filter factory. The given factory function must return a filter
     * function that returns true if the key matches the filter criteria, false
     * otherwise.
     *
     * @param name The name of the key filter.
     * @param factory The filter factory function.
     */
    template<typename Criteria>
    void setKeyFilter(const std::string&, std::function<std::function<bool (const Key&)> (const Criteria&)>);

    /**
     * Set a sample filter factory. The given factory function must return a filter
     * function that returns true if the sample matches the filter criteria, false
     * otherwise.
     *
     * @param name The name of the sample filter.
     * @param factory The filter factory function.
     */
    template<typename Criteria>
    void setSampleFilter(const std::string&,
                         std::function<std::function<bool (const Sample<Key, Value, UpdateTag>&)> (const Criteria&)>);

private:

    std::shared_ptr<DataStormI::TopicReader> getReader() const;
    std::shared_ptr<DataStormI::TopicWriter> getWriter() const;
    std::shared_ptr<Ice::Communicator> getCommunicator() const;

    template<typename, typename, typename> friend class KeyWriter;
    template<typename, typename, typename> friend class KeyReader;
    template<typename, typename, typename> friend class MultiKeyWriter;
    template<typename, typename, typename> friend class MultiKeyReader;
    template<typename, typename, typename> friend class FilteredKeyReader;

    const std::string _name;
    const std::shared_ptr<DataStormI::TopicFactory> _topicFactory;
    const std::shared_ptr<DataStormI::KeyFactoryT<Key>> _keyFactory;
    const std::shared_ptr<DataStormI::TagFactoryT<UpdateTag>> _tagFactory;

    const std::shared_ptr<DataStormI::FilterManagerT<
       DataStormI::KeyT<Key>>> _keyFilterFactories;
    const std::shared_ptr<DataStormI::FilterManagerT<
       DataStormI::SampleT<Key, Value, UpdateTag>>> _sampleFilterFactories;

    mutable std::mutex _mutex;
    mutable std::shared_ptr<DataStormI::TopicReader> _reader;
    mutable std::shared_ptr<DataStormI::TopicWriter> _writer;
    mutable std::map<std::shared_ptr<DataStormI::Tag>, DataStormI::Topic::Updater> _updaters;
};

/**
 * The Reader class is used to retrieve samples for a data element.
 */
template<typename Key, typename Value, typename UpdateTag>
class Reader
{
public:

    /**
     * The key type.
     */
    using KeyType = Key;

    /**
     * The value type.
     */
    using ValueType = Value;

    /**
     * The writer identifier type. The tuple first element is the session ID,
     * the second element is the peer topic opaque ID and the third is the
     * peer data writer opaque ID.
     */
    using WriterId = std::tuple<std::string, long long int, long long int>;

    /**
     * Transfers the given reader to this reader.
     *
     * @param reader The reader.
     **/
    Reader(Reader&&);

    /**
     * Destruct the reader. The destruction of the reader disconnects
     * the reader from the writers.
     */
    ~Reader();

    /**
     * Move assignement operator
     *
     * @param reader The reader.
     **/
    Reader& operator=(Reader&&);

    /**
     * Indicates whether or not writers are online.
     *
     * @return True if writers are connected, false otherwise.
     */
    bool hasWriters() const;

    /**
     * Wait for given number of writers to be online.
     *
     * @param count The number of writers to wait.
     */
    void waitForWriters(unsigned int = 1) const;

    /**
     * Wait for readers to be offline.
     */
    void waitForNoWriters() const;

    /**
     * Get the keys for which writers are connected to this reader.
     *
     * @return The keys for which we have writers connected.
     **/
    std::vector<Key> getConnectedKeys() const;

    /**
     * Returns all the unread samples.
     *
     * @return The unread samples.
     */
    std::vector<Sample<Key, Value, UpdateTag>> getAllUnread();

    /**
     * Wait for given number of unread samples to be available.
     */
    void waitForUnread(unsigned int = 1) const;

    /**
     * Returns wether or not unread samples are available.
     */
    bool hasUnread() const;

    /**
     * Returns the next unread sample.
     *
     * @return The unread sample.
     */
    Sample<Key, Value, UpdateTag> getNextUnread();

    /**
     * Calls the given function when a new key writer connects to this reader.
     *
     * @param callback The function to call when a new reader disconnects. The ID and
     *                 the key are provided to the callback.
     *
     * @see Sample<K, V, U>::getOrigin
     **/
    void onKeyConnect(std::function<void(WriterId, Key)>);

    /**
     * Calls the given function when a new key writer disconnects from this reader.
     *
     * @param callback The function to call when a new reader disconnects. The ID and
     *                 the key are provided to the callback.
     *
     * @see Sample<K, V, U>::getOrigin
     **/
    void onKeyDisconnect(std::function<void(WriterId, Key)>);

    /**
     * Calls the given function when a new filter writer connects to this reader.
     *
     * @param callback The function to call when a new reader disconnects. The ID and
     *                 the filter name are provided to the callback.
     *
     * @see Sample<K, V, U>::getOrigin
     **/
    void onFilterConnect(std::function<void(WriterId, std::string)>);

    /**
     * Calls the given function when a new filter writer disconnects from this reader.
     *
     * @param callback The function to call when a new reader disconnects. The ID and
     *                 the filter name are provided to the callback.
     *
     * @see Sample<K, V, U>::getOrigin
     **/
    void onFilterDisconnect(std::function<void(WriterId, std::string)>);

    /**
     * Calls the given function when samples are queued with this reader. If a
     * function is already set, it will be replaced with this new function.
     *
     * @param callback The function to call when samples are received.
     **/
    void onSamples(std::function<void(std::vector<Sample<Key, Value, UpdateTag>>)>);

protected:

    /** @private */
    Reader(const std::shared_ptr<DataStormI::DataReader>& impl) : _impl(impl)
    {
    }

    /** @private */
    std::shared_ptr<DataStormI::DataReader> _impl;
};

/**
 * The key reader to read the data element associated with a given key.
 */
template<typename Key, typename Value, typename UpdateTag=std::string>
class KeyReader : public Reader<Key, Value, UpdateTag>
{
public:

    /**
     * Construct a new reader for the given key. The construction of the reader
     * connects the reader to writers with a matching key.
     *
     * @param topic The topic.
     * @param key The key of the data element to read.
     * @param config The reader configuration.
     */
    KeyReader(const Topic<Key, Value, UpdateTag>&, const Key&, const ReaderConfig& = ReaderConfig());

    /**
     * Construct a new reader for the given key and sample filter criteria. The
     * construction of the reader connects the reader to writers with a matching
     * key. The writer will only send samples matching the given sample filter
     * criteria to the reader.
     *
     * @param topic The topic.
     * @param key The key of the data element to read.
     * @param sampleFilter The sample filter name.
     * @param sampleFilterCriteria The sample filter criteria.
     * @param config The reader configuration.
     */
    template<typename SampleFilterCriteria>
    KeyReader(const Topic<Key, Value, UpdateTag>&,
              const Key&,
              const std::string&,
              const SampleFilterCriteria&,
              const ReaderConfig& = ReaderConfig());

    /**
     * Transfers the given reader to this reader.
     *
     * @param reader The reader.
     **/
    KeyReader(KeyReader&&);

    /**
     * Move assignement operator.
     *
     * @param reader The reader.
     **/
    KeyReader& operator=(KeyReader&&);
};

/**
 * The key reader to read the data element associated with a given set of keys.
 */
template<typename Key, typename Value, typename UpdateTag=std::string>
class MultiKeyReader : public Reader<Key, Value, UpdateTag>
{
public:

    /**
     * Construct a new reader for the given keys. The construction of the reader
     * connects the reader to writers with matching keys.
     *
     * @param topic The topic.
     * @param keys The keys of the data elements to read.
     * @param config The reader configuration.
     */
    MultiKeyReader(const Topic<Key, Value, UpdateTag>&, const std::vector<Key>&, const ReaderConfig& = ReaderConfig());

    /**
     * Construct a new reader for the given keys and sample filter criteria. The
     * construction of the reader connects the reader to writers with matching
     * keys. The writer will only send samples matching the given sample filter
     * criteria to the reader.
     *
     * @param topic The topic.
     * @param keys The keys of the data elements to read.
     * @param sampleFilter The sample filter name.
     * @param sampleFilterCriteria The sample filter criteria.
     * @param config The reader configuration.
     */
    template<typename SampleFilterCriteria>
    MultiKeyReader(const Topic<Key, Value, UpdateTag>&,
                   const std::vector<Key>&,
                   const std::string&,
                   const SampleFilterCriteria&,
                   const ReaderConfig& = ReaderConfig());

    /**
     * Transfers the given reader to this reader.
     *
     * @param reader The reader.
     **/
    MultiKeyReader(MultiKeyReader&&);

    /**
     * Move assignement operator.
     *
     * @param reader The reader.
     **/
    MultiKeyReader& operator=(MultiKeyReader&&);
};

/**
 * Creates a key reader for the given topic and key. This helper method deduces the
 * topic Key, Value and UpdateTag types from the topic argument.
 *
 * @param topic The topic.
 * @param key The key.
 * @param config The optional reader configuration.
 */
template<typename K, typename V, typename UT>
KeyReader<K, V, UT>
makeSingleKeyReader(const Topic<K, V, UT>& topic,
                    const typename Topic<K, V, UT>::KeyType& key,
                    const ReaderConfig& config = ReaderConfig())
{
    return KeyReader<K, V, UT>(topic, key, config);
}

/**
 * Creates a shared key reader for the given topic and key. This helper method deduces the
 * topic Key, Value and UpdateTag types from the topic argument.
 *
 * @param topic The topic.
 * @param key The key.
 * @param config The optional reader configuration.
 */
template<typename K, typename V, typename UT>
std::shared_ptr<KeyReader<K, V, UT>>
makeSharedSingleKeyReader(const Topic<K, V, UT>& topic,
                          const typename Topic<K, V, UT>::KeyType& key,
                          const ReaderConfig& config = ReaderConfig())
{
    return std::make_shared<KeyReader<K, V, UT>>(topic, key, config);
}

/**
 * Creates a key reader for the given topic, key and sample filter. This helper method
 * deduces the topic Key and Value types from the topic argument.
 *
 * @param topic The topic.
 * @param key The key.
 * @param sampleFilter The sample filter name.
 * @param sampleFilterCriteria The sample filter criteria.
 * @param config The optional reader configuration.
 */
template<typename SFC, typename K, typename V, typename UT>
KeyReader<K, V, UT>
makeSingleKeyReader(const Topic<K, V, UT>& topic,
                    const typename Topic<K, V, UT>::KeyType& key,
                    const std::string& sampleFilter,
                    const SFC& sampleFilterCriteria,
                    const ReaderConfig& config = ReaderConfig())
{
    return KeyReader<K, V, UT>(topic, key, sampleFilter, sampleFilterCriteria, config);
}

/**
 * Creates a shared key reader for the given topic, key and sample filter. This helper
 * method deduces the topic Key and Value types from the topic argument.
 *
 * @param topic The topic.
 * @param key The key.
 * @param sampleFilter The sample filter name.
 * @param sampleFilterCriteria The sample filter criteria.
 * @param config The optional reader configuration.
 */
template<typename SFC, typename K, typename V, typename UT>
std::shared_ptr<KeyReader<K, V, UT>>
makeSharedSingleKeyReader(const Topic<K, V, UT>& topic,
                          const typename Topic<K, V, UT>::KeyType& key,
                          const std::string& sampleFilter,
                          const SFC& sampleFilterCriteria,
                          const ReaderConfig& config = ReaderConfig())
{
    return std::make_shared<KeyReader<K, V, UT>>(topic, key, sampleFilter, sampleFilterCriteria, config);
}

/**
 * Creates a multi-key reader for the given topic. This helper method deduces the
 * topic Key, Value and UpdateTag types from the topic argument.
 *
 * The reader will only receive samples for the given set of keys.
 *
 * @param topic The topic.
 * @param keys The keys.
 * @param config The optional reader configuration.
 */
template<typename K, typename V, typename UT> MultiKeyReader<K, V, UT>
makeMultiKeyReader(const Topic<K, V, UT>& topic,
                   const std::vector<typename Topic<K, V, UT>::KeyType>& keys,
                   const ReaderConfig& config = ReaderConfig())
{
    return MultiKeyReader<K, V, UT>(topic, keys, config);
}

/**
 * Creates a shared multi-key reader for the given topic and keys. This helper
 * method deduces the topic Key, Value and UpdateTag types from the topic argument.
 *
 * The reader will only receive samples for the given set of keys.
 *
 * @param topic The topic.
 * @param keys The keys.
 * @param config The optional reader configuration.
 */
template<typename K, typename V, typename UT> std::shared_ptr<MultiKeyReader<K, V, UT>>
makeSharedMultiKeyReader(const Topic<K, V, UT>& topic,
                         const std::vector<typename Topic<K, V, UT>::KeyType>& keys,
                         const ReaderConfig& config = ReaderConfig())
{
    return std::make_shared<MultiKeyReader<K, V, UT>>(topic, keys, config);
}

/**
 * Creates a multi-key reader for the given topic, keys and sample filter. This
 * helper method deduces the topic Key and Value types from the topic argument.
 *
 * The reader will only receive samples for the given set of keys.
 *
 * @param topic The topic.
 * @param keys The keys.
 * @param sampleFilter The sample filter name.
 * @param sampleFilterCriteria The sample filter criteria.
 * @param config The optional reader configuration.
 */
template<typename SFC, typename K, typename V, typename UT> MultiKeyReader<K, V, UT>
makeMultiKeyReader(const Topic<K, V, UT>& topic,
                   const std::vector<typename Topic<K, V, UT>::KeyType>& keys,
                   const std::string& sampleFilter,
                   const SFC& sampleFilterCriteria,
                   const ReaderConfig& config = ReaderConfig())
{
    return MultiKeyReader<K, V, UT>(topic, keys, sampleFilter, sampleFilterCriteria, config);
}

/**
 * Creates a shared multi-key reader for the given topic, keys and sample filter.
 * This helper method deduces the topic Key and Value types from the topic argument.
 *
 * The reader will only receive samples for the given set of keys.
 *
 * @param topic The topic.
 * @param keys The keys.
 * @param sampleFilter The sample filter name.
 * @param sampleFilterCriteria The sample filter criteria.
 * @param config The optional reader configuration.
 */
template<typename SFC, typename K, typename V, typename UT> std::shared_ptr<MultiKeyReader<K, V, UT>>
makeSharedMultiKeyReader(const Topic<K, V, UT>& topic,
                         const std::vector<typename Topic<K, V, UT>::KeyType>& keys,
                         const std::string& sampleFilter,
                         const SFC& sampleFilterCriteria,
                         const ReaderConfig& config = ReaderConfig())
{
    return std::make_shared<MultiKeyReader<K, V, UT>>(topic, keys, sampleFilter, sampleFilterCriteria, config);
}

/**
 * Creates an any-key reader for the given topic. This helper method deduces
 * the topic Key, Value and UpdateTag types from the topic argument.
 *
 * The reader will receive samples for any keys from the topic.
 *
 * @param topic The topic.
 * @param config The optional reader configuration.
 */
template<typename K, typename V, typename UT> MultiKeyReader<K, V, UT>
makeAnyKeyReader(const Topic<K, V, UT>& topic, const ReaderConfig& config = ReaderConfig())
{
    return MultiKeyReader<K, V, UT>(topic, {}, config);
}

/**
 * Creates a shared any-key reader for the given topic. This helper method deduces
 * the topic Key, Value and UpdateTag types from the topic argument.
 *
 * The reader will receive samples for any keys from the topic.
 *
 * @param topic The topic.
 * @param config The optional reader configuration.
 */
template<typename K, typename V, typename UT> std::shared_ptr<MultiKeyReader<K, V, UT>>
makeSharedAnyKeyReader(const Topic<K, V, UT>& topic, const ReaderConfig& config = ReaderConfig())
{
    return std::make_shared<MultiKeyReader<K, V, UT>>(topic, std::vector<K> {}, config);
}

/**
 * Creates an any-key reader for the given topic and sample filter. This helper
 * method deduces the topic Key and Value types from the topic argument.
 *
 * The reader will receive samples for the keys from the topic.
 *
 * @param topic The topic.
 * @param sampleFilter The sample filter.
 * @param sampleFilterCriteria The sample filter criteria.
 * @param config The optional reader configuration.
 */
template<typename SFC, typename K, typename V, typename UT> MultiKeyReader<K, V, UT>
makeAnyKeyReader(const Topic<K, V, UT>& topic,
                 const std::string& sampleFilter,
                 const SFC& sampleFilterCriteria,
                 const ReaderConfig& config = ReaderConfig())
{
    return MultiKeyReader<K, V, UT>(topic, {}, sampleFilter, sampleFilterCriteria, config);
}

/**
 * Creates a shared any-key reader for the given topic and sample filter. This helper
 * method deduces the topic Key and Value types from the topic argument.
 *
 * The reader will receive samples for the keys from the topic.
 *
 * @param topic The topic.
 * @param sampleFilter The sample filter.
 * @param sampleFilterCriteria The sample filter criteria.
 * @param config The optional reader configuration.
 */
template<typename SFC, typename K, typename V, typename UT> std::shared_ptr<MultiKeyReader<K, V, UT>>
makeSharedAnyKeyReader(const Topic<K, V, UT>& topic,
                       const std::string& sampleFilter,
                       const SFC& sampleFilterCriteria,
                       const ReaderConfig& config = ReaderConfig())
{
    return std::make_shared<MultiKeyReader<K, V, UT>>(topic, {}, sampleFilter, sampleFilterCriteria, config);
}

/**
 * The filtered reader to read data elements whose key match a given filter.
 */
template<typename Key, typename Value, typename UpdateTag=std::string>
class FilteredKeyReader : public Reader<Key, Value, UpdateTag>
{
public:

    /**
     * Construct a new reader for the given key filter. The construction of the reader
     * connects the reader to writers whose key matches the key filter criteria.
     *
     * @param topic The topic.
     * @param filter The filter name.
     * @param criteria The filter criteria.
     * @param config The reader configuration.
     */
    template<typename KeyFilterCriteria>
    FilteredKeyReader(const Topic<Key, Value, UpdateTag>&,
                      const std::string&,
                      const KeyFilterCriteria&,
                      const ReaderConfig& = ReaderConfig());

    /**
     * Construct a new reader for the given key filter and sample filter criterias. The
     * construction of the reader connects the reader to writers whose key matches the
     * key filter criteria.
     *
     * @param topic The topic.
     * @param keyFilter The key filter name.
     * @param keyFilterCriteria The key filter criteria used by writers to filter the keys.
     * @param sampleFilter The sample filter name.
     * @param sampleFilterCriteria The sample filter criteria used by writers to filter the samples.
     * @param config The reader configuration.
     */
    template<typename KeyFilterCriteria, typename SampleFilterCriteria>
    FilteredKeyReader(const Topic<Key, Value, UpdateTag>&,
                      const std::string&,
                      const KeyFilterCriteria&,
                      const std::string&,
                      const SampleFilterCriteria&,
                      const ReaderConfig& = ReaderConfig());

    /**
     * Transfers the given reader to this reader.
     *
     * @param reader The reader.
     **/
    FilteredKeyReader(FilteredKeyReader&&);

    /**
     * Move assignement operator.
     *
     * @param reader The reader.
     **/
    FilteredKeyReader& operator=(FilteredKeyReader&&);
};

/**
 * Creates a new filtered reader for the given topic and key filter. This helper method
 * deduces the topic Key, Value and UpdateTag types from the topic argument.
 *
 * @param topic The topic.
 * @param filter The key filter name.
 * @param criteria The key filter criteria.
 * @param config The optional reader configuration.
 */
template<typename KFC, typename K, typename V, typename UT> FilteredKeyReader<K, V, UT>
makeFilteredKeyReader(const Topic<K, V, UT>& topic,
                      const std::string& filter,
                      const KFC& criteria,
                      const ReaderConfig& config = ReaderConfig())
{
    return FilteredKeyReader<K, V, UT>(topic, filter, criteria, config);
}

/**
 * Creates a new shared filtered reader for the given topic and key filter. This helper
 * method deduces the topic Key, Value and UpdateTag types from the topic argument.
 *
 * @param topic The topic.
 * @param filter The key filter name.
 * @param criteria The key filter criteria.
 * @param config The optional reader configuration.
 */
template<typename KFC, typename K, typename V, typename UT> std::shared_ptr<FilteredKeyReader<K, V, UT>>
makeSharedFilteredKeyReader(const Topic<K, V, UT>& topic,
                            const std::string& filter,
                            const KFC& criteria,
                            const ReaderConfig& config = ReaderConfig())
{
    return std::make_shared<FilteredKeyReader<K, V, UT>>(topic, filter, criteria, config);
}

/**
 * Creates a new filter reader for the given topic, key filter and sample filter. This
 * helper method deduces the topic Key, Value and UpdateTag types from the topic argument.
 *
 * @param topic The topic.
 * @param keyFilter The key filter name.
 * @param keyFilterCriteria The key filter criteria.
 * @param sampleFilter The sample filter name.
 * @param sampleFilterCriteria The sample filter criteria.
 * @param config The optional reader configuration.
 */
template<typename KFC, typename SFC, typename K, typename V, typename UT> FilteredKeyReader<K, V, UT>
makeFilteredKeyReader(const Topic<K, V, UT>& topic,
                      const std::string& keyFilter,
                      const KFC& keyFilterCriteria,
                      const std::string& sampleFilter,
                      const SFC& sampleFilterCriteria,
                      const ReaderConfig& config = ReaderConfig())
{
    return FilteredKeyReader<K, V, UT>(topic, keyFilter, keyFilterCriteria, sampleFilter, sampleFilterCriteria, config);
}

/**
 * Creates a new shared filtered reader for the given topic, key filter and sample
 * filter. This helper method deduces the topic Key, Value and UpdateTag types from
 * the topic argument.
 *
 * @param topic The topic.
 * @param keyFilter The key filter name.
 * @param keyFilterCriteria The key filter criteria.
 * @param sampleFilter The sample filter name.
 * @param sampleFilterCriteria The sample filter criteria.
 * @param config The optional reader configuration.
 */
template<typename KFC, typename SFC, typename K, typename V, typename UT> std::shared_ptr<FilteredKeyReader<K, V, UT>>
makeSharedFilteredKeyReader(const Topic<K, V, UT>& topic,
                            const std::string& keyFilter,
                            const KFC& keyFilterCriteria,
                            const std::string& sampleFilter,
                            const SFC& sampleFilterCriteria,
                            const ReaderConfig& config = ReaderConfig())
{
    return std::make_shared<FilteredKeyReader<K, V, UT>>(topic, keyFilter, keyFilterCriteria, sampleFilter,
                                                         sampleFilterCriteria, config);
}

/**
 * The writer class is used to write samples for a data element.
 */
template<typename Key, typename Value, typename UpdateTag>
class Writer
{
public:

    /**
     * The key type.
     */
    using KeyType = Key;

    /**
     * The value type.
     */
    using ValueType = Value;

    /**
     * The reader identifier type. The tuple first element is the session ID,
     * the second element is the peer topic opaque ID and the third is the
     * peer data reader opaque ID.
     */
    using ReaderId = std::tuple<std::string, long long int, long long int>;

    /**
     * Transfers the given writer to this writer.
     *
     * @param writer The writer.
     **/
    Writer(Writer&&);

    /**
     * Move assignement operator.
     *
     * @param writer The writer.
     **/
    Writer& operator=(Writer&&);

    /**
     * Destruct the writer. The destruction of the writer disconnects
     * the writer from the readers.
     */
    ~Writer();

    /**
     * Indicates whether or not readers are online.
     *
     * @return True if readers are connected, false otherwise.
     */
    bool hasReaders() const;

    /**
     * Wait for given number of readers to be online.
     *
     * @param count The number of readers to wait.
     */
    void waitForReaders(unsigned int = 1) const;

    /**
     * Wait for readers to be offline.
     */
    void waitForNoReaders() const;

    /**
     * Get the keys for which readers are connected to this writer.
     *
     * @return The keys for which we have writers connected.
     **/
    std::vector<Key> getConnectedKeys() const;

    /**
     * Get the last written sample.
     *
     * @return The last written sample.
     **/
    Sample<Key, Value, UpdateTag> getLast();

    /**
     * Get all the written sample kept in the writer history.
     *
     * @return The sample history.
     **/
    std::vector<Sample<Key, Value, UpdateTag>> getAll();

    /**
     *
     * Calls the given function when a new key reader connects to this writer.
     *
     * @param callback The function to call when a new reader disconnects. The ID and
     *                 the key are provided to the callback.
     *
     * @see Sample<K, V, U>::getOrigin
     **/
    void onKeyConnect(std::function<void(ReaderId, Key)>);

    /**
     *
     * Calls the given function when a new key reader disconnects from this writer.
     *
     * @param callback The function to call when a new reader disconnects. The ID and
     *                 the key are provided to the callback.
     *
     * @see Sample<K, V, U>::getOrigin
     **/
    void onKeyDisconnect(std::function<void(ReaderId, Key)>);

    /**
     *
     * Calls the given function when a new filter reader connects to this writer.
     *
     * @param callback The function to call when a new reader disconnects. The ID and
     *                 the filter name are provided to the callback.
     *
     * @see Sample<K, V, U>::getOrigin
     **/
    void onFilterConnect(std::function<void(ReaderId, std::string)>);

    /**
     *
     * Calls the given function when a new filter reader disconnects from this writer.
     *
     * @param callback The function to call when a new reader disconnects. The ID and
     *                 the filter name are provided to the callback.
     *
     * @see Sample<K, V, U>::getOrigin
     **/
    void onFilterDisconnect(std::function<void(ReaderId, std::string)>);

protected:

    /** @private */
    Writer(const std::shared_ptr<DataStormI::DataWriter>& impl) : _impl(impl)
    {
    }

    /** @private */
    std::shared_ptr<DataStormI::DataWriter> _impl;
};

/**
 * The key writer to write the data element associated with a given key.
 */
template<typename Key, typename Value, typename UpdateTag=std::string>
class KeyWriter : public Writer<Key, Value, UpdateTag>
{
public:

    /**
     * Construct a new writer for the given key. The construction of the writer
     * connects the writer to readers with a matching key.
     *
     * @param topic The topic.
     * @param key The key of the data element to write.
     * @param config The writer configuration.
     */
    KeyWriter(const Topic<Key, Value, UpdateTag>&, const Key&, const WriterConfig& = WriterConfig());

    /**
     * Move constructor.
     *
     * @param writer The writer.
     **/
    KeyWriter(KeyWriter&&);

    /**
     * Move assignement operator.
     *
     * @param writer The writer.
     **/
    KeyWriter& operator=(KeyWriter&&);

    /**
     * Add the data element. This generates an {@link Add} sample with the
     * given value.
     *
     * @param value The data element value.
     */
    void add(const Value&);

    /**
     * Update the data element. This generates an {@link Update} sample with the
     * given value.
     *
     * @param value The data element value.
     */
    void update(const Value&);

    /**
     * Partially update the data element. This generates a {@link PartialUpdate} sample
     * with the given partial update value.
     *
     * The Update template parameter is deduced by the compiler from the value parameter.
     * Specifying the UpdateValue type is still necessary. It should match the UpdateValue
     * type used to register the updater with the {@link Topic::setUpdater}.
     *
     * @param tag The partial update tag.
     * @param value The partial update value.
     */
    template<typename UpdateValue, typename Update> void update(const UpdateTag&, const Update&);

    /**
     * Remove the data element. This generates a {@link Remove} sample.
     */
    void remove();

private:

    const std::shared_ptr<DataStormI::TagFactoryT<UpdateTag>> _tagFactory;
};

/**
 * The key writer to write data elements associated with a given set of keys.
 */
template<typename Key, typename Value, typename UpdateTag=std::string>
class MultiKeyWriter : public Writer<Key, Value, UpdateTag>
{
public:

    /**
     * Construct a new writer for the given key. The construction of the writer
     * connects the writer to readers with a matching key.
     *
     * @param topic The topic.
     * @param keys The keys.
     * @param config The writer configuration.
     */
    MultiKeyWriter(const Topic<Key, Value, UpdateTag>&, const std::vector<Key>&, const WriterConfig& = WriterConfig());

    /**
     * Transfers the given writer to this writer.
     *
     * @param writer The writer.
     **/
    MultiKeyWriter(MultiKeyWriter&&);

    /**
     * Move assignement operator.
     *
     * @param writer The writer.
     **/
    MultiKeyWriter& operator=(MultiKeyWriter&&);

    /**
     * Add the data element. This generates an {@link Add} sample with the
     * given value.
     *
     * @param key The key
     * @param value The data element value.
     */
    void add(const Key&, const Value&);

    /**
     * Update the data element. This generates an {@link Update} sample with the
     * given value.
     *
     * @param key The key
     * @param value The data element value.
     */
    void update(const Key&, const Value&);

    /**
     * Partially update the data element. This generates a {@link PartialUpdate} sample
     * with the given partial update value.
     *
     * The Update template parameter is deduced by the compiler from the value parameter.
     * Specifying the UpdateValue type is still necessary. It should match the UpdateValue
     * type used to register the updater with the {@link Topic::setUpdater}.
     *
     * @param key The key
     * @param tag The partial update tag.
     * @param value The partial update value.
     */
    template<typename UpdateValue, typename Update> void update(const Key&, const UpdateTag&, const Update&);

    /**
     * Remove the data element. This generates a {@link Remove} sample.

     * @param key The key
     */
    void remove(const Key&);

private:

    const std::shared_ptr<DataStormI::KeyFactoryT<Key>> _keyFactory;
    const std::shared_ptr<DataStormI::TagFactoryT<UpdateTag>> _tagFactory;
};

/**
 * Creates a key writer for the given topic and key. This helper method deduces
 * the topic Key, Value and UpdateTag types from the topic argument.
 *
 * @param topic The topic.
 * @param key The key.
 * @param config The optional writer configuration.
 */
template<typename K, typename V, typename UT> KeyWriter<K, V, UT>
makeSingleKeyWriter(const Topic<K, V, UT>& topic,
                    const typename Topic<K, V, UT>::KeyType& key,
                    const WriterConfig& config = WriterConfig())
{
    return KeyWriter<K, V, UT>(topic, key, config);
}

/**
 * Creates a shared key writer for the given topic and key. This helper method deduces
 * the topic Key, Value and UpdateTag types from the topic argument.
 *
 * @param topic The topic.
 * @param key The key.
 * @param config The optional writer configuration.
 */
template<typename K, typename V, typename UT> std::shared_ptr<KeyWriter<K, V, UT>>
makeSharedSingleKeyWriter(const Topic<K, V, UT>& topic,
                          const typename Topic<K, V, UT>::KeyType& key,
                          const WriterConfig& config = WriterConfig())
{
    return std::make_shared<KeyWriter<K, V, UT>>(topic, key, config);
}

/**
 * Creates a multi-key writer for the given topic and keys. This helper method deduces
 * the topic Key, Value and UpdateTag types from the topic argument.
 *
 * @param topic The topic.
 * @param keys The keys.
 * @param config The optional writer configuration.
 */
template<typename K, typename V, typename UT> MultiKeyWriter<K, V, UT>
makeMultiKeyWriter(const Topic<K, V, UT>& topic,
                   const std::vector<typename Topic<K, V, UT>::KeyType>& keys,
                   const WriterConfig& config = WriterConfig())
{
    return MultiKeyWriter<K, V, UT>(topic, keys, config);
}

/**
 * Creates a shared multi-key writer for the given topic and keys. This helper method deduces
 * the topic Key, Value and UpdateTag types from the topic argument.
 *
 * @param topic The topic.
 * @param keys The keys.
 * @param config The optional writer configuration.
 */
template<typename K, typename V, typename UT> std::shared_ptr<MultiKeyWriter<K, V, UT>>
makeSharedMultiKeyWriter(const Topic<K, V, UT>& topic,
                         const std::vector<typename Topic<K, V, UT>::KeyType>& keys,
                         const WriterConfig& config = WriterConfig())
{
    return std::make_shared<MultiKeyWriter<K, V, UT>>(topic, keys, config);
}

/**
 * Creates an any-key writer for the given topic. This helper method deduces
 * the topic Key, Value and UpdateTag types from the topic argument.
 *
 * @param topic The topic.
 * @param config The optional writer configuration.
 */
template<typename K, typename V, typename UT> MultiKeyWriter<K, V, UT>
makeAnyKeyWriter(const Topic<K, V, UT>& topic, const WriterConfig& config = WriterConfig())
{
    return MultiKeyWriter<K, V, UT>(topic, {}, config);
}

/**
 * Creates a shared any-key writer for the given topic. This helper method deduces
 * the topic Key, Value and UpdateTag types from the topic argument.
 *
 * @param topic The topic.
 * @param config The optional writer configuration.
 */
template<typename K, typename V, typename UT> std::shared_ptr<MultiKeyWriter<K, V, UT>>
makeSharedAnyKeyWriter(const Topic<K, V, UT>& topic, const WriterConfig& config = WriterConfig())
{
    return std::make_shared<MultiKeyWriter<K, V, UT>>(topic, std::vector<K> {}, config);
}

}

//
// Public template based API implementation
//

namespace DataStorm
{

//
// Sample template implementation
//
template<typename Key, typename Value, typename UpdateTag> SampleEvent
Sample<Key, Value, UpdateTag>::getEvent() const
{
    return _impl->event;
}

template<typename Key, typename Value, typename UpdateTag> const Key&
Sample<Key, Value, UpdateTag>::getKey() const
{
    return _impl->getKey();
}

template<typename Key, typename Value, typename UpdateTag> const Value&
Sample<Key, Value, UpdateTag>::getValue() const
{
    return _impl->getValue();
}

template<typename Key, typename Value, typename UpdateTag> UpdateTag
Sample<Key, Value, UpdateTag>::getUpdateTag() const
{
    return _impl->getTag();
}

template<typename Key, typename Value, typename UpdateTag> std::chrono::time_point<std::chrono::system_clock>
Sample<Key, Value, UpdateTag>::getTimeStamp() const
{
    return _impl->timestamp;
}

template<typename Key, typename Value, typename UpdateTag> std::tuple<std::string, long long int, long long int>
Sample<Key, Value, UpdateTag>::getOrigin() const
{
    return std::make_tuple(_impl->session, _impl->topic, _impl->element);
}

template<typename Key, typename Value, typename UpdateTag> Sample<Key, Value, UpdateTag>::Sample(
    const std::shared_ptr<DataStormI::Sample>& impl) :
    _impl(std::static_pointer_cast<DataStormI::SampleT<Key, Value, UpdateTag>>(impl))
{
}

//
// Reader template implementation
//
template<typename Key, typename Value, typename UpdateTag>
Reader<Key, Value, UpdateTag>::Reader(Reader<Key, Value, UpdateTag>&& reader) : _impl(std::move(reader._impl))
{
}

template<typename Key, typename Value, typename UpdateTag>
Reader<Key, Value, UpdateTag>::~Reader()
{
    if(_impl)
    {
        _impl->destroy();
    }
}

template<typename Key, typename Value, typename UpdateTag> Reader<Key, Value, UpdateTag>&
Reader<Key, Value, UpdateTag>::operator=(Reader&& reader)
{
    _impl = std::move(reader._impl);
    return *this;
}

template<typename Key, typename Value, typename UpdateTag> bool
Reader<Key, Value, UpdateTag>::hasWriters() const
{
    return _impl->hasWriters();
}

template<typename Key, typename Value, typename UpdateTag> void
Reader<Key, Value, UpdateTag>::waitForWriters(unsigned int count) const
{
    _impl->waitForWriters(count);
}

template<typename Key, typename Value, typename UpdateTag> void
Reader<Key, Value, UpdateTag>::waitForNoWriters() const
{
    _impl->waitForWriters(-1);
}

template<typename Key, typename Value, typename UpdateTag> std::vector<Key>
Reader<Key, Value, UpdateTag>::getConnectedKeys() const
{
    std::vector<Key> keys;
    auto connectedKeys = _impl->getConnectedKeys();
    keys.reserve(connectedKeys.size());
    for(const auto& k : connectedKeys)
    {
        keys.push_back(std::static_pointer_cast<DataStormI::KeyT<Key>>(k)->get());
    }
    return keys;
}

template<typename Key, typename Value, typename UpdateTag> std::vector<Sample<Key, Value, UpdateTag>>
Reader<Key, Value, UpdateTag>::getAllUnread()
{
    auto unread = _impl->getAllUnread();
    std::vector<Sample<Key, Value, UpdateTag>> samples;
    samples.reserve(unread.size());
    for(auto sample : unread)
    {
        samples.emplace_back(sample);
    }
    return samples;
}

template<typename Key, typename Value, typename UpdateTag> void
Reader<Key, Value, UpdateTag>::waitForUnread(unsigned int count) const
{
    _impl->waitForUnread(count);
}

template<typename Key, typename Value, typename UpdateTag> bool
Reader<Key, Value, UpdateTag>::hasUnread() const
{
    return _impl->hasUnread();
}

template<typename Key, typename Value, typename UpdateTag> Sample<Key, Value, UpdateTag>
Reader<Key, Value, UpdateTag>::getNextUnread()
{
    return Sample<Key, Value, UpdateTag>(_impl->getNextUnread());
}

template<typename Key, typename Value, typename UpdateTag> void
Reader<Key, Value, UpdateTag>::onKeyConnect(std::function<void(WriterId, Key)> callback)
{
    if(callback)
    {
        _impl->onKeyConnect([callback](WriterId id, std::shared_ptr<DataStormI::Key> k) {
            callback(id, std::static_pointer_cast<DataStormI::KeyT<Key>>(k)->get());
        });
    }
    else
    {
        _impl->onKeyConnect(nullptr);
    }
}

template<typename Key, typename Value, typename UpdateTag> void
Reader<Key, Value, UpdateTag>::onKeyDisconnect(std::function<void(WriterId, Key)> callback)
{
    if(callback)
    {
        _impl->onKeyDisconnect([callback](WriterId id, std::shared_ptr<DataStormI::Key> k) {
            callback(id, std::static_pointer_cast<DataStormI::KeyT<Key>>(k)->get());
        });
    }
    else
    {
        _impl->onKeyDisconnect(nullptr);
    }
}

template<typename Key, typename Value, typename UpdateTag> void
Reader<Key, Value, UpdateTag>::onFilterConnect(std::function<void(WriterId, std::string)> callback)
{
    if(callback)
    {
        _impl->onFilterConnect([callback](WriterId id, std::shared_ptr<DataStormI::Filter> f) {
            callback(id, f->getName());
        });
    }
    else
    {
        _impl->onFilterConnect(nullptr);
    }
}

template<typename Key, typename Value, typename UpdateTag> void
Reader<Key, Value, UpdateTag>::onFilterDisconnect(std::function<void(WriterId, std::string)> callback)
{
    if(callback)
    {
        _impl->onFilterDisconnect([callback](WriterId id, std::shared_ptr<DataStormI::Filter> f) {
            callback(id, f->getName());
        });
    }
    else
    {
        _impl->onFilterDisconnect(nullptr);
    }
}

template<typename Key, typename Value, typename UpdateTag> void
Reader<Key, Value, UpdateTag>::onSamples(std::function<void(std::vector<Sample<Key, Value, UpdateTag>>)> callback)
{
    auto communicator = _impl->getCommunicator();
    _impl->onSamples([communicator, callback](const std::vector<std::shared_ptr<DataStormI::Sample>>& samplesI)
    {
        std::vector<Sample<Key, Value, UpdateTag>> samples;
        samples.reserve(samplesI.size());
        for(const auto& s : samplesI)
        {
            samples.emplace_back(s);
        }
        callback(move(samples));
    });
}

template<typename Key, typename Value, typename UpdateTag>
KeyReader<Key, Value, UpdateTag>::KeyReader(const Topic<Key, Value, UpdateTag>& topic,
                                            const Key& key,
                                            const ReaderConfig& config) :
    Reader<Key, Value, UpdateTag>(topic.getReader()->create({ topic._keyFactory->create(key) }, config))
{
}

template<typename Key, typename Value, typename UpdateTag> template<typename SFC>
KeyReader<Key, Value, UpdateTag>::KeyReader(const Topic<Key, Value, UpdateTag>& topic,
                                            const Key& key,
                                            const std::string& sampleFilter,
                                            const SFC& sampleFilterCriteria,
                                            const ReaderConfig& config) :
    Reader<Key, Value, UpdateTag>(topic.getReader()->create({ topic._keyFactory->create(key) },
                                                            config,
                                                            sampleFilter,
                                                            DataStormI::EncoderT<SFC>::encode(topic.getCommunicator(),
                                                                                              sampleFilterCriteria)))
{
}

template<typename Key, typename Value, typename UpdateTag>
KeyReader<Key, Value, UpdateTag>::KeyReader(KeyReader<Key, Value, UpdateTag>&& reader) :
    Reader<Key, Value, UpdateTag>(std::move(reader))
{
}

template<typename Key, typename Value, typename UpdateTag> KeyReader<Key, Value, UpdateTag>&
KeyReader<Key, Value, UpdateTag>::operator=(KeyReader&& reader)
{
    Reader<Key, Value, UpdateTag>::operator=(std::move(reader));
    return *this;
}

template<typename Key, typename Value, typename UpdateTag>
MultiKeyReader<Key, Value, UpdateTag>::MultiKeyReader(const Topic<Key, Value, UpdateTag>& topic,
                                                      const std::vector<Key>& keys,
                                                      const ReaderConfig& config) :
    Reader<Key, Value, UpdateTag>(topic.getReader()->create(topic._keyFactory->create(keys), config))
{
}

template<typename Key, typename Value, typename UpdateTag> template<typename SFC>
MultiKeyReader<Key, Value, UpdateTag>::MultiKeyReader(const Topic<Key, Value, UpdateTag>& topic,
                                                      const std::vector<Key>& keys,
                                                      const std::string& sampleFilter,
                                                      const SFC& sampleFilterCriteria,
                                                      const ReaderConfig& config) :
    Reader<Key, Value, UpdateTag>(topic.getReader()->create(
        topic._keyFactory->create(keys), config,
        sampleFilter, Encoder<SFC>::encode(topic.getCommunicator(), sampleFilterCriteria)))
{
}

template<typename Key, typename Value, typename UpdateTag>
MultiKeyReader<Key, Value, UpdateTag>::MultiKeyReader(MultiKeyReader<Key, Value, UpdateTag>&& reader) :
    Reader<Key, Value, UpdateTag>(std::move(reader))
{
}

template<typename Key, typename Value, typename UpdateTag>
MultiKeyReader<Key, Value, UpdateTag>&
MultiKeyReader<Key, Value, UpdateTag>::operator=(MultiKeyReader&& reader)
{
    Reader<Key, Value, UpdateTag>::operator=(std::move(reader));
    return *this;
}

template<typename Key, typename Value, typename UpdateTag> template<typename KFC>
FilteredKeyReader<Key, Value, UpdateTag>::FilteredKeyReader(const Topic<Key, Value, UpdateTag>& topic,
                                                            const std::string& filter,
                                                            const KFC& criteria,
                                                            const ReaderConfig& config) :
    Reader<Key, Value, UpdateTag>(topic.getReader()->createFiltered(
        topic._keyFilterFactories->create(filter, KFC(criteria)), config))
{
}

template<typename Key, typename Value, typename UpdateTag> template<typename KFC, typename SFC>
FilteredKeyReader<Key, Value, UpdateTag>::FilteredKeyReader(const Topic<Key, Value, UpdateTag>& topic,
                                                            const std::string& keyFilter,
                                                            const KFC& keyFilterCriteria,
                                                            const std::string& sampleFilter,
                                                            const SFC& sampleFilterCriteria,
                                                            const ReaderConfig& config) :
    Reader<Key, Value, UpdateTag>(topic.getReader()->createFiltered(
        topic._keyFilterFactories->create(keyFilter, KFC(keyFilterCriteria)),
        config,
        sampleFilter, Encoder<SFC>::encode(topic.getCommunicator(), sampleFilterCriteria)))
{
}

template<typename Key, typename Value, typename UpdateTag>
FilteredKeyReader<Key, Value, UpdateTag>::FilteredKeyReader(FilteredKeyReader<Key, Value, UpdateTag>&& reader) :
    Reader<Key, Value, UpdateTag>(std::move(reader))
{
}

template<typename Key, typename Value, typename UpdateTag> FilteredKeyReader<Key, Value, UpdateTag>&
FilteredKeyReader<Key, Value, UpdateTag>::operator=(FilteredKeyReader&& reader)
{
    Reader<Key, Value, UpdateTag>::operator=(std::move(reader));
    return *this;
}

//
// Writer template implementation
//
template<typename Key, typename Value, typename UpdateTag>
Writer<Key, Value, UpdateTag>::Writer(Writer&& writer) : _impl(std::move(writer._impl))
{
}

template<typename Key, typename Value, typename UpdateTag> Writer<Key, Value, UpdateTag>&
Writer<Key, Value, UpdateTag>::operator=(Writer&& writer)
{
    _impl = std::move(writer._impl);
    return *this;
}

template<typename Key, typename Value, typename UpdateTag>
Writer<Key, Value, UpdateTag>::~Writer()
{
    if(_impl)
    {
        _impl->destroy();
    }
}

template<typename Key, typename Value, typename UpdateTag> bool
Writer<Key, Value, UpdateTag>::hasReaders() const
{
    return _impl->hasReaders();
}

template<typename Key, typename Value, typename UpdateTag> void
Writer<Key, Value, UpdateTag>::waitForReaders(unsigned int count) const
{
    return _impl->waitForReaders(count);
}

template<typename Key, typename Value, typename UpdateTag> void
Writer<Key, Value, UpdateTag>::waitForNoReaders() const
{
    return _impl->waitForReaders(-1);
}

template<typename Key, typename Value, typename UpdateTag> std::vector<Key>
Writer<Key, Value, UpdateTag>::getConnectedKeys() const
{
    std::vector<Key> keys;
    auto connectedKeys = _impl->getConnectedKeys();
    keys.reserve(connectedKeys.size());
    for(const auto& k : connectedKeys)
    {
        keys.push_back(std::static_pointer_cast<DataStormI::KeyT<Key>>(k)->get());
    }
    return keys;
}

template<typename Key, typename Value, typename UpdateTag> Sample<Key, Value, UpdateTag>
Writer<Key, Value, UpdateTag>::getLast()
{
    auto sample = _impl->getLast();
    if(!sample)
    {
        throw std::invalid_argument("no sample");
    }
    return Sample<Key, Value, UpdateTag>(sample);
}

template<typename Key, typename Value, typename UpdateTag> std::vector<Sample<Key, Value, UpdateTag>>
Writer<Key, Value, UpdateTag>::getAll()
{
    auto all = _impl->getAll();
    std::vector<Sample<Key, Value, UpdateTag>> samples;
    samples.reserve(all.size());
    for(auto sample : all)
    {
        samples.emplace_back(sample);
    }
    return samples;
}

template<typename Key, typename Value, typename UpdateTag> void
Writer<Key, Value, UpdateTag>::onKeyConnect(std::function<void(ReaderId, Key)> callback)
{
    if(callback)
    {
        _impl->onKeyConnect([callback](ReaderId id, std::shared_ptr<DataStormI::Key> k) {
            callback(id, std::static_pointer_cast<DataStormI::KeyT<Key>>(k)->get());
        });
    }
    else
    {
        _impl->onKeyConnect(nullptr);
    }
}

template<typename Key, typename Value, typename UpdateTag> void
Writer<Key, Value, UpdateTag>::onKeyDisconnect(std::function<void(ReaderId, Key)> callback)
{
    if(callback)
    {
        _impl->onKeyDisconnect([callback](ReaderId id, std::shared_ptr<DataStormI::Key> k) {
            callback(id, std::static_pointer_cast<DataStormI::KeyT<Key>>(k)->get());
        });
    }
    else
    {
        _impl->onKeyDisconnect(nullptr);
    }
}

template<typename Key, typename Value, typename UpdateTag> void
Writer<Key, Value, UpdateTag>::onFilterConnect(std::function<void(ReaderId, std::string)> callback)
{
    if(callback)
    {
        _impl->onFilterConnect([callback](ReaderId id, std::shared_ptr<DataStormI::Filter> f) {
            callback(id, f->getName());
        });
    }
    else
    {
        _impl->onFilterConnect(nullptr);
    }
}

template<typename Key, typename Value, typename UpdateTag> void
Writer<Key, Value, UpdateTag>::onFilterDisconnect(std::function<void(ReaderId, std::string)> callback)
{
    if(callback)
    {
        _impl->onFilterDisconnect([callback](ReaderId id, std::shared_ptr<DataStormI::Filter> f) {
            callback(id, f->getName());
        });
    }
    else
    {
        _impl->onFilterDisconnect(nullptr);
    }
}

template<typename Key, typename Value, typename UpdateTag>
KeyWriter<Key, Value, UpdateTag>::KeyWriter(const Topic<Key, Value, UpdateTag>& topic,
                                            const Key& key,
                                            const WriterConfig& config) :
    Writer<Key, Value, UpdateTag>(topic.getWriter()->create({ topic._keyFactory->create(key) },
                                                            config)),
    _tagFactory(topic._tagFactory)
{
}

template<typename Key, typename Value, typename UpdateTag>
KeyWriter<Key, Value, UpdateTag>::KeyWriter(KeyWriter<Key, Value, UpdateTag>&& writer) :
    Writer<Key, Value, UpdateTag>(std::move(writer)),
    _tagFactory(std::move(writer._tagFactory))
{
}

template<typename Key, typename Value, typename UpdateTag> KeyWriter<Key, Value, UpdateTag>&
KeyWriter<Key, Value, UpdateTag>::operator=(KeyWriter&& writer)
{
    Writer<Key, Value, UpdateTag>::operator=(std::move(writer));
    return *this;
}

template<typename Key, typename Value, typename UpdateTag> void
KeyWriter<Key, Value, UpdateTag>::add(const Value& value)
{
   Writer<Key, Value, UpdateTag>::_impl->publish(nullptr,
        std::make_shared<DataStormI::SampleT<Key, Value, UpdateTag>>(SampleEvent::Add, value));
}

template<typename Key, typename Value, typename UpdateTag> void
KeyWriter<Key, Value, UpdateTag>::update(const Value& value)
{
    Writer<Key, Value, UpdateTag>::_impl->publish(nullptr,
        std::make_shared<DataStormI::SampleT<Key, Value, UpdateTag>>(SampleEvent::Update, value));
}

template<typename Key, typename Value, typename UpdateTag>
template<typename UpdateValue, typename Update> void
KeyWriter<Key, Value, UpdateTag>::update(const UpdateTag& tag, const Update& value)
{
    auto encoded = Encoder<UpdateValue>::encode(Writer<Key, Value, UpdateTag>::_impl->getCommunicator(), value);
    Writer<Key, Value, UpdateTag>::_impl->publish(nullptr,
        std::make_shared<DataStormI::SampleT<Key, Value, UpdateTag>>(encoded, _tagFactory->create(tag)));
}

template<typename Key, typename Value, typename UpdateTag> void
KeyWriter<Key, Value, UpdateTag>::remove()
{
    Writer<Key, Value, UpdateTag>::_impl->publish(nullptr,
        std::make_shared<DataStormI::SampleT<Key, Value, UpdateTag>>(SampleEvent::Remove));
}

template<typename Key, typename Value, typename UpdateTag>
MultiKeyWriter<Key, Value, UpdateTag>::MultiKeyWriter(const Topic<Key, Value, UpdateTag>& topic,
                                                      const std::vector<Key>& keys,
                                                      const WriterConfig& config) :
    Writer<Key, Value, UpdateTag>(topic.getWriter()->create(topic._keyFactory->create(keys), config)),
    _keyFactory(topic._keyFactory),
    _tagFactory(topic._tagFactory)
{
}

template<typename Key, typename Value, typename UpdateTag>
MultiKeyWriter<Key, Value, UpdateTag>::MultiKeyWriter(MultiKeyWriter<Key, Value, UpdateTag>&& writer) :
    Writer<Key, Value, UpdateTag>(std::move(writer)),
    _keyFactory(std::move(writer._keyFactory)),
    _tagFactory(std::move(writer._tagFactory))
{
}

template<typename Key, typename Value, typename UpdateTag> MultiKeyWriter<Key, Value, UpdateTag>&
MultiKeyWriter<Key, Value, UpdateTag>::operator=(MultiKeyWriter&& writer)
{
    Writer<Key, Value, UpdateTag>::operator=(std::move(writer));
    return *this;
}

template<typename Key, typename Value, typename UpdateTag> void
MultiKeyWriter<Key, Value, UpdateTag>::add(const Key& key, const Value& value)
{
    Writer<Key, Value, UpdateTag>::_impl->publish(_keyFactory->create(key),
        std::make_shared<DataStormI::SampleT<Key, Value, UpdateTag>>(SampleEvent::Add, value));
}

template<typename Key, typename Value, typename UpdateTag> void
MultiKeyWriter<Key, Value, UpdateTag>::update(const Key& key, const Value& value)
{
    Writer<Key, Value, UpdateTag>::_impl->publish(_keyFactory->create(key),
        std::make_shared<DataStormI::SampleT<Key, Value, UpdateTag>>(SampleEvent::Update, value));
}

template<typename Key, typename Value, typename UpdateTag>
template<typename UpdateValue, typename Update> void
MultiKeyWriter<Key, Value, UpdateTag>::update(const Key& key, const UpdateTag& tag, const Update& value)
{
    auto encoded = Encoder<UpdateValue>::encode(Writer<Key, Value, UpdateTag>::_impl->getCommunicator(), value);
    Writer<Key, Value, UpdateTag>::_impl->publish(_keyFactory->create(key),
        std::make_shared<DataStormI::SampleT<Key, Value, UpdateTag>>(encoded, _tagFactory->create(tag)));
}

template<typename Key, typename Value, typename UpdateTag> void
MultiKeyWriter<Key, Value, UpdateTag>::remove(const Key& key)
{
    Writer<Key, Value, UpdateTag>::_impl->publish(_keyFactory->create(key),
        std::make_shared<DataStormI::SampleT<Key, Value, UpdateTag>>(SampleEvent::Remove));
}

#if !defined(__clang__) && defined(__GNUC__) && ((__GNUC__* 100) + __GNUC_MINOR__) < 490

#include <regex.h>

/** @private */
class RegExp
{
public:

    RegExp(const std::string& criteria)
    {
        if(regcomp(&_expr, criteria.c_str(), REG_EXTENDED) != 0)
        {
            throw std::invalid_argument(criteria);
        }
    }

    ~RegExp()
    {
        regfree(&_expr);
    }

    bool match(const std::string& value) const
    {
        return regexec(&_expr, value.c_str(), 0, 0, 0) == 0;
    }

private:

    regex_t _expr;
};

#endif

/** @private */
template<typename Value> std::function<std::function<bool (const Value&)> (const std::string&)>
makeRegexFilter()
{
    return [](const std::string& criteria)
    {
#if !defined(__clang__) && defined(__GNUC__) && ((__GNUC__* 100) + __GNUC_MINOR__) < 490
        auto expr = std::make_shared<RegExp>(criteria);
        return [expr](const Value& value)
        {
            std::ostringstream os;
            os << value;
            return expr->match(os.str());
        };
#else
        std::regex expr(criteria);
        return [expr](const Value& value)
        {
            std::ostringstream os;
            os << value;
            return std::regex_match(os.str(), expr);
        };
#endif
    };
}

/** @private */
template<typename Key, typename Value, typename UpdateTag>
std::function<std::function<bool (const Sample<Key, Value, UpdateTag>&)> (const std::vector<SampleEvent>&)>
makeSampleEventFilter(const Topic<Key, Value, UpdateTag>& topic)
{
    return [](const std::vector<SampleEvent>& criteria)
    {
        return [criteria](const Sample<Key, Value, UpdateTag>& sample)
        {
            return std::find(criteria.begin(), criteria.end(), sample.getEvent()) != criteria.end();
        };
    };
}

/** @private */
template<typename T, typename V, typename Enabler=void>
struct RegexFilter
{
    template<typename F> static void
    add(F factory)
    {
    }
};

/** @private */
template<typename T, typename V>
struct RegexFilter<T, V, typename std::enable_if<DataStormI::is_streamable<V>::value>::type>
{
    template<typename F> static void
    add(F factory)
    {
        factory->set("_regex", makeRegexFilter<T>()); // Only set the _regex filter if the value is streamable
    }
};

//
// Topic template implementation
//
template<typename Key, typename Value, typename UpdateTag>
Topic<Key, Value, UpdateTag>::Topic(const Node& node, const std::string& name) :
    _name(name),
    _topicFactory(node._factory),
    _keyFactory(DataStormI::KeyFactoryT<Key>::createFactory()),
    _tagFactory(DataStormI::TagFactoryT<UpdateTag>::createFactory()),
    _keyFilterFactories(DataStormI::FilterManagerT<DataStormI::KeyT<Key>>::create()),
    _sampleFilterFactories(DataStormI::FilterManagerT<DataStormI::SampleT<Key, Value, UpdateTag>>::create())
{
    RegexFilter<Key, Key>::add(_keyFilterFactories);
    RegexFilter<Sample<Key, Value, UpdateTag>, Value>::add(_sampleFilterFactories);
    _sampleFilterFactories->set("_event", makeSampleEventFilter(*this));
}

template<typename Key, typename Value, typename UpdateTag>
Topic<Key, Value, UpdateTag>::Topic(Topic<Key, Value, UpdateTag>&& topic) :
    _name(std::move(topic._name)),
    _topicFactory(std::move(topic._topicFactory)),
    _keyFactory(std::move(topic._keyFactory)),
    _tagFactory(std::move(topic._tagFactory)),
    _keyFilterFactories(std::move(topic._keyFilterFactories)),
    _sampleFilterFactories(std::move(topic._sampleFilterFactories)),
    _reader(std::move(topic._reader)),
    _writer(std::move(topic._writer)),
    _updaters(std::move(topic._updaters))
{
}

template<typename Key, typename Value, typename UpdateTag>
Topic<Key, Value, UpdateTag>::~Topic()
{
    std::lock_guard<std::mutex> lock(_mutex);
    if(_reader)
    {
        _reader->destroy();
    }
    if(_writer)
    {
        _writer->destroy();
    }
}

template<typename Key, typename Value, typename UpdateTag> Topic<Key, Value, UpdateTag>&
Topic<Key, Value, UpdateTag>::operator=(Topic<Key, Value, UpdateTag>&& topic)
{
    _name = std::move(topic._name);
    _topicFactory = std::move(topic._topicFactory);
    _keyFactory = std::move(topic._keyFactory);
    _tagFactory = std::move(topic._tagFactory);
    _keyFilterFactories = std::move(topic._keyFilterFactories);
    _sampleFilterFactories = std::move(topic._sampleFilterFactories);
    _reader = std::move(topic._reader);
    _writer = std::move(topic._writer);
    _updaters = std::move(topic._updaters);
    return *this;
}

template<typename Key, typename Value, typename UpdateTag> bool
Topic<Key, Value, UpdateTag>::hasWriters() const
{
    return getReader()->hasWriters();
}

template<typename Key, typename Value, typename UpdateTag> void
Topic<Key, Value, UpdateTag>::waitForWriters(unsigned int count) const
{
    getReader()->waitForWriters(count);
}

template<typename Key, typename Value, typename UpdateTag> void
Topic<Key, Value, UpdateTag>::waitForNoWriters() const
{
    getReader()->waitForWriters(-1);
}

template<typename Key, typename Value, typename UpdateTag> void
Topic<Key, Value, UpdateTag>::setReaderDefaultConfig(const ReaderConfig& config)
{
    getReader()->setDefaultConfig(config);
}

template<typename Key, typename Value, typename UpdateTag> bool
Topic<Key, Value, UpdateTag>::hasReaders() const
{
    return getWriter()->hasReaders();
}

template<typename Key, typename Value, typename UpdateTag> void
Topic<Key, Value, UpdateTag>::waitForReaders(unsigned int count) const
{
    getWriter()->waitForReaders(count);
}

template<typename Key, typename Value, typename UpdateTag> void
Topic<Key, Value, UpdateTag>::waitForNoReaders() const
{
    getWriter()->waitForReaders(-1);
}

template<typename Key, typename Value, typename UpdateTag> void
Topic<Key, Value, UpdateTag>::setWriterDefaultConfig(const WriterConfig& config)
{
    getWriter()->setDefaultConfig(config);
}

template<typename Key, typename Value, typename UpdateTag> template<typename UpdateValue> void
Topic<Key, Value, UpdateTag>::setUpdater(const UpdateTag& tag, std::function<void (Value&, UpdateValue)> updater)
{
    std::lock_guard<std::mutex> lock(_mutex);
    auto tagI = _tagFactory->create(std::move(tag));
    auto updaterImpl = [updater](const std::shared_ptr<DataStormI::Sample>& previous,
                                 const std::shared_ptr<DataStormI::Sample>& next,
                                 const std::shared_ptr<Ice::Communicator>& communicator)
    {
        Value value;
        if(previous)
        {
            value = Cloner<Value>::clone(
                std::static_pointer_cast<DataStormI::SampleT<Key, Value, UpdateTag>>(previous)->getValue());
        }
        updater(value, Decoder<UpdateValue>::decode(communicator, next->getEncodedValue()));
        std::static_pointer_cast<DataStormI::SampleT<Key, Value, UpdateTag>>(next)->setValue(std::move(value));
    };

    if(_reader && !_writer)
    {
        _reader->setUpdater(tagI, updaterImpl);
    }
    else if(_writer && !_reader)
    {
        _writer->setUpdater(tagI, updaterImpl);
    }
    else if(_reader && _writer)
    {
        _reader->setUpdater(tagI, updaterImpl);
        _writer->setUpdater(tagI, updaterImpl);
    }
    else
    {
        _updaters[tagI] = updaterImpl;
    }
}

template<typename Key, typename Value, typename UpdateTag> template<typename Criteria> void
Topic<Key, Value, UpdateTag>::setKeyFilter(const std::string& name,
    std::function<std::function<bool (const Key&)>(const Criteria&)> factory)
{
    std::lock_guard<std::mutex> lock(_mutex);
    _keyFilterFactories->set(name, factory);
}

template<typename Key, typename Value, typename UpdateTag> template<typename Criteria> void
Topic<Key, Value, UpdateTag>::setSampleFilter(const std::string& name,
    std::function<std::function<bool (const Sample<Key, Value, UpdateTag>&)>(const Criteria&)> factory)
{
    std::lock_guard<std::mutex> lock(_mutex);
    _sampleFilterFactories->set(name, factory);
}

template<typename Key, typename Value, typename UpdateTag> std::shared_ptr<DataStormI::TopicReader>
Topic<Key, Value, UpdateTag>::getReader() const
{
    std::lock_guard<std::mutex> lock(_mutex);
    if(!_reader)
    {
        auto sampleFactory = std::make_shared<DataStormI::SampleFactoryT<Key, Value, UpdateTag>>();
        _reader = _topicFactory->createTopicReader(_name, _keyFactory, _tagFactory, sampleFactory, _keyFilterFactories,
                                                   _sampleFilterFactories);
        _reader->setUpdaters(_writer ? _writer->getUpdaters() : _updaters);
        _updaters.clear();
    }
    return _reader;
}

template<typename Key, typename Value, typename UpdateTag> std::shared_ptr<DataStormI::TopicWriter>
Topic<Key, Value, UpdateTag>::getWriter() const
{
    std::lock_guard<std::mutex> lock(_mutex);
    if(!_writer)
    {
        _writer = _topicFactory->createTopicWriter(_name, _keyFactory, _tagFactory, nullptr, _keyFilterFactories,
                                                   _sampleFilterFactories);
        _writer->setUpdaters(_reader ? _reader->getUpdaters() : _updaters);
        _updaters.clear();
    }
    return _writer;
}

template<typename Key, typename Value, typename UpdateTag> std::shared_ptr<Ice::Communicator>
Topic<Key, Value, UpdateTag>::getCommunicator() const
{
    return _topicFactory->getCommunicator();
}

}
