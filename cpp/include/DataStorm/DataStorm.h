// **********************************************************************
//
// Copyright (c) 2003-2017 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************

#pragma once

#include <DataStorm/Config.h>

#include <Ice/Communicator.h>
#include <Ice/Initialize.h>
#include <Ice/InputStream.h>
#include <Ice/OutputStream.h>

#include <DataStorm/SampleType.h>
#include <DataStorm/Filter.h>
#include <DataStorm/Node.h>
#include <DataStorm/InternalI.h>
#include <DataStorm/InternalT.h>

#include <regex>

/**
 * \mainpage %DataStorm API Reference
 *
 * \section namespaces Namespaces
 *
 * @ref DataStorm â€” The %DataStorm core library.
 */
namespace DataStorm
{

template<typename K, typename V> class KeyReader;
template<typename K, typename V> class KeyWriter;
template<typename K, typename V> class FilteredReader;
template<typename K, typename V> class FilteredWriter;

/**
 * The Encoder template provides methods to encode and decode user types.
 *
 * The encoder template can be specialized to provide encodeling and un-encodeling
 * methods for types that don't support being encodeled with Ice. By default, the
 * Ice encodeling is used if no Encoder template specialization is provided for the
 * type.
 */
template<typename T> struct Encoder
{
    /**
     * Marshals the given value. This method encodes the given value and returns the
     * resulting byte sequence. The factory parameter is provided to allow the implementation
     * to retrieve configuration or any other information required by the marhsalling.
     *
     * @see decode
     *
     * @param communicator The communicator associated with the node
     * @param value The value to encode
     * @return The resulting byte sequence
     */
    static std::vector<unsigned char> encode(const std::shared_ptr<Ice::Communicator>&, const T&);

    /**
     * Unencodes a value. This method decodes the given byte sequence and returns the
     * resulting value. The factory parameter is provided to allow the implementation
     * to retrieve configuration or any other information required by the un-encodeling.
     *
     * @see encode
     *
     * @param communicator The communicator associated with the node
     * @param value The byte sequence to decode
     * @return The resulting value
     */
    static T decode(const std::shared_ptr<Ice::Communicator>&, const std::vector<unsigned char>&);
};

template<typename T> struct Stringifier
{
    /**
     * Transforms the given value to a string. Specialization can define this to provide
     * a custom stringification implementation. The default implementation uses
     * `std::ostream::operator<<` to transform the value to a string. This option is
     * mandatory for key types.
     *
     * @param value The value to stringify
     * @return The string representation of the value
     */
    static std::string toString(const T&);
};

/**
 * A sample provides information about an update of a data element.
 *
 * The Sample template provides access to key, value and type of
 * an update to a data element.
 *
 */
template<typename Key, typename Value> class Sample
{
public:

    using KeyType = Key;
    using ValueType = Value;

    /**
     * The type of the sample.
     *
     * @return The sample type.
     */
    SampleType getType() const;

    /**
     * The key of the sample.
     *
     * @return The sample key.
     */
    Key getKey() const;

    /**
     * The value of the sample.
     *
     * Depending on the sample type, the sample value might not always be
     * available. It is for instance the case if the sample type is Remove.
     *
     * @return The sample value.
     */
    Value getValue() const;

    /**
     * The timestamp of the sample.
     *
     * The timestamp is generated by the writer. It corresponds to time at
     * which the sample was sent.
     *
     * TODO: use C++11 type.
     *
     * @return The timestamp.
     */
    IceUtil::Time getTimestamp() const;


    /** @private */
    Sample(const std::shared_ptr<DataStormInternal::Sample>&);

private:

    const std::shared_ptr<DataStormInternal::SampleT<Key, Value>> _impl;
};

/**
 * The RegexKeyFilter template filters keys matching a regular expression.
 **/
template<typename K, typename V> class RegexKeyFilter
{
public:

    /**
     * The type used to initialize and encode/decode the filter over the wire.
     */
    using FilterType = std::string;

    /**
     * Construct the filter with the given filter value.
     *
     * @param value The value of the filter.
     */
    RegexKeyFilter(const std::string& value) : _regex(value)
    {
    }

    /**
     * Returns wether or not the key matches the regular expression.
     *
     * @param key The key to match against the regular expression.
     * @return True if the key matches the regular expression, false otherwise.
     */
    bool match(const K& key) const
    {
        return std::regex_match(DataStorm::Stringifier<K>::toString(key), _regex);
    }

private:

    std::regex _regex;
};

/**
 * The RegexKeyValueFilter template filters keys and values matching regular expressions
 * and a set of sample types.
 **/
template<typename K, typename V> struct RegexKeyValueFilter
{
public:

    /**
     * The type used to initialize and encode/decode the filter over the wire.
     */
    using FilterType = RegexFilter;

    /**
     * Construct the filter with the given RegexFilter value.
     *
     * @param value The value of the filter.
     */
    RegexKeyValueFilter(const RegexFilter& value) : _filter(value), _key(value.key), _value(value.value)
    {
    }

    /**
     * Returns wether or not the key matches the key regular expression.
     *
     * @param key The key to match against the key regular expression.
     * @return True if the key matches the key regular expression, false otherwise.
     */
    bool match(const K& key) const
    {
        if(!_filter.key.empty())
        {
            return std::regex_match(DataStorm::Stringifier<K>::toString(key), _key);
        }
        return true;
    }

    /**
     * Returns wether or not the sample matches the value regular expression
     * and sample types. This method is invoked by writers to figure out if
     * it should send or not the sample to the reader.
     *
     * @param sample The sample to match against the filter.
     * @return True if the sample type matches the filter sample types, false otherwise.
     */
    bool writerMatch(const Sample<K, V>& sample) const
    {
        if(!_filter.types.empty())
        {
            if(std::find(_filter.types.begin(), _filter.types.end(), sample.getType()) == _filter.types.end())
            {
                return false;
            }
        }
        return true;
    }

    /**
     * Returns wether or not the sample matches the value regular expression
     * and sample types. This method is invoked by the reader when receiving
     * sample to figure out whether or not it should deliver the sample to the
     * reader.
     *
     * @param sample The sample to match against the filter.
     * @return True if the sample value matches the value regular expression, false otherwise.
     */
    bool readerMatch(const Sample<K, V>& sample) const
    {
        if(!_filter.value.empty())
        {
            return std::regex_match(DataStorm::Stringifier<V>::toString(sample.getValue()), _value);
        }
        return true;
    }

private:

    const RegexFilter _filter;
    const std::regex _key;
    const std::regex _value;
};

std::ostream&
operator<<(std::ostream& os, SampleType sampleType)
{
    switch(sampleType)
    {
    case SampleType::Add:
        os << "Add";
        break;
    case SampleType::Update:
        os << "Update";
        break;
    case SampleType::Remove:
        os << "Remove";
        break;
    default:
        os << static_cast<int>(sampleType);
        break;
    }
    return os;
}

std::ostream&
operator<<(std::ostream& os, const RegexFilter& filter)
{
    bool sep = false;
    if(!filter.key.empty())
    {
        os << "key=" << filter.key;
        sep = true;
    }
    if(sep)
    {
        os << ' ';
        sep = false;
    }
    if(!filter.value.empty())
    {
        os << "value=" << filter.value;
        sep = true;
    }
    if(sep)
    {
        os << ' ';
        sep = false;
    }
    if(!filter.types.empty())
    {
        os << "types=[";
        for(auto p = filter.types.begin(); p != filter.types.end(); ++p)
        {
            if(p != filter.types.begin())
            {
                os << ',';
            }
            os << *p;
        }
        os << "]";
    }
    return os;
};

/**
 * The Topic class allows to construct Reader and Writer objects.
 */
template<typename Key, typename Value, typename Filter=RegexKeyFilter<Key, Value>> class Topic
{
public:

    using KeyType = Key;
    using ValueType = Value;
    using FilterType = Filter;

    /**
     * Construct a new Topic for the topic with the given name.
     *
     * @param node The DataStorm node
     * @param name The name of the topic
     */
    Topic(Node&, const std::string&);

    /**
     * Construct a new Topic by taking ownership of the given topic.
     *
     * @param topic The topic to transfer ownership from.
     */
    Topic(Topic&&);

    /**
     * Destruct the Topic. This disconnects the topic from peers.
     */
    ~Topic();

    /**
     * Indicates whether or not topic writers are online.
     *
     * @return True if topic writers are connected, false otherwise.
     */
    bool hasWriters() const;

    /**
     * Wait for given number of topic writers to be online.
     *
     * @param count The number of topic writers to wait.
     */
    void waitForWriters(unsigned int = 1) const;

    /**
     * Wait for topic writers to be offline.
     */
    void waitForNoWriters() const;

    /**
     * Indicates whether or not topic readers are online.
     *
     * @return True if topic readers are connected, false otherwise.
     */
    bool hasReaders() const;

    /**
     * Wait for given number of topic readers to be online.
     *
     * @param count The number of topic readers to wait.
     */
    void waitForReaders(unsigned int = 1) const;

    /**
     * Wait for topic readers to be offline.
     */
    void waitForNoReaders() const;

private:

    std::shared_ptr<DataStormInternal::TopicReader> getReader() const;
    std::shared_ptr<DataStormInternal::TopicWriter> getWriter() const;

    friend class KeyWriter<Key, Value>;
    friend class FilteredWriter<Key, Value>;
    friend class KeyReader<Key, Value>;
    friend class FilteredReader<Key, Value>;

    const std::string _name;
    const std::shared_ptr<DataStormInternal::TopicFactory> _topicFactory;
    const std::shared_ptr<DataStormInternal::KeyFactoryT<Key>> _keyFactory;
    const std::shared_ptr<DataStormInternal::FilterFactoryT<Key, Value, Filter>> _filterFactory;

    mutable std::mutex _mutex;
    mutable std::shared_ptr<DataStormInternal::TopicReader> _reader;
    mutable std::shared_ptr<DataStormInternal::TopicWriter> _writer;
};

/**
 * The Reader class is used to retrieve samples for a data element.
 */
template<typename Key, typename Value> class Reader
{
public:

    using KeyType = Key;
    using ValueType = Value;

    /**
     * Destruct the reader. The destruction of the reader disconnects
     * the reader from the writers.
     */
    ~Reader();

    /**
     * Indicates whether or not writers are online.
     *
     * @return True if writers are connected, false otherwise.
     */
    bool hasWriters() const;

    /**
     * Wait for given number of writers to be online.
     *
     * @param count The number of writers to wait.
     */
    void waitForWriters(unsigned int = 1) const;

    /**
     * Wait for writers to be offline.
     */
    void waitForNoWriters() const;

    /**
     * Returns the number of times the data element was instantiated.
     *
     * This returns the number of times {@link Writer::add} was called for the
     * data element.
     */
    int getInstanceCount() const;

    /**
     * Returns all the data samples available with this reader.
     *
     * @return The data samples.
     */
    std::vector<Sample<Key, Value>> getAll() const;

    /**
     * Returns all the unread data samples.
     *
     * @return The unread data samples.
     */
    std::vector<Sample<Key, Value>> getAllUnread();

    /**
     * Wait for given number of unread data samples to be available.
     */
    void waitForUnread(unsigned int = 1) const;

    /**
     * Returns wether or not data unread data samples are available.
     */
    bool hasUnread() const;

    /**
     * Returns the next unread data sample.
     *
     * @return The unread data sample.
     */
    Sample<Key, Value> getNextUnread();

protected:

    /** @private */
    Reader(const std::shared_ptr<DataStormInternal::DataReader>& impl) : _impl(impl)
    {
    }

    /** @private */
    Reader(Reader&& reader) : _impl(std::move(reader._impl))
    {
    }

private:

    std::shared_ptr<DataStormInternal::DataReader> _impl;
};

/**
 * The key reader to read the data element associated with a given key.
 */
template<typename Key, typename Value> class KeyReader : public Reader<Key, Value>
{
public:

    /**
     * Construct a new reader for the given key. The construction of the reader
     * connects the reader to writers with a matching key.
     *
     * @param topic The topic reader.
     * @param key The key of the data element to read.
     */
    template<typename Filter>
    KeyReader(Topic<Key, Value, Filter>&, const Key&);

    /**
     * Construct a new reader for the given keys. The construction of the reader
     * connects the reader to writers with matching keys.
     *
     * @param topic The topic reader.
     * @param keys The keys of the data elements to read.
     */
    template<typename Filter>
    KeyReader(Topic<Key, Value, Filter>&, const std::vector<Key>&);

    /**
     * Transfers the given reader to this reader.
     *
     * @param reader The reader.
     **/
    KeyReader(KeyReader&&);
};

/**
 * The filtered reader to read data elements whose key match a given filter.
 */
template<typename Key, typename Value> class FilteredReader : public Reader<Key, Value>
{
public:

    /**
     * Construct a new reader for the given filter. The construction of the reader
     * connects the reader to writers whose key matches the filter.
     *
     * @param topic The topic reader.
     * @param filter The filter.
     */
    template<typename Filter>
    FilteredReader(Topic<Key, Value, Filter>&, const typename Filter::FilterType&);

    /**
     * Transfers the given reader to this reader.
     *
     * @param reader The reader.
     **/
    FilteredReader(FilteredReader&&);
};

/**
 * The Writer class is used to write samples for a data element.
 */
template<typename Key, typename Value> class Writer
{
public:

    using KeyType = Key;
    using ValueType = Value;

    /**
     * Destruct the writer. The destruction of the writer disconnects
     * the writer from the readers.
     */
    ~Writer();

    /**
     * Indicates whether or not readers are online.
     *
     * @return True if readers are connected, false otherwise.
     */
    bool hasReaders() const;

    /**
     * Wait for given number of readers to be online.
     *
     * @param count The number of readers to wait.
     */
    void waitForReaders(unsigned int = 1) const;

    /**
     * Wait for readers to be offline.
     */
    void waitForNoReaders() const;

    /**
     * Add the data element. This generates an {@link Add} data sample with the
     * given value.
     *
     * @param value The data element value.
     */
    void add(const Value&);

    /**
     * Update the data element. This generates an {@link Update} data sample with the
     * given value.
     *
     * @param value The data element value.
     */
    void update(const Value&);

    /**
     * Remove the data element. This generates a {@link Remove} data sample.
     */
    void remove();

protected:

    /** @private */
    Writer(const std::shared_ptr<DataStormInternal::DataWriter>& impl) : _impl(impl)
    {
    }

    /** @private */
    Writer(Writer&& writer) : _impl(std::move(writer.impl))
    {
    }

private:

    std::shared_ptr<DataStormInternal::DataWriter> _impl;
};

/**
 * The key writer to write the data element associated with a given key.
 */
template<typename Key, typename Value> class KeyWriter : public Writer<Key, Value>
{
public:

    /**
     * Construct a new writer for the given key. The construction of the writer
     * connects the writer to readers with a matching key.
     *
     * @param topic The topic writer.
     * @param key The key of the data element to write.
     */
    template<typename Filter>
    KeyWriter(Topic<Key, Value, Filter>&, const Key&);

    /**
     * Construct a new writer for the given keys. The construction of the writer
     * connects the writer to readers with matching keys.
     *
     * @param topic The topic writer.
     * @param keys The key of the data elements to write.
     */
    template<typename Filter>
    KeyWriter(Topic<Key, Value, Filter>&, const std::vector<Key>&);

    /**
     * Transfers the given writer to this writer.
     *
     * @param writer The writer.
     **/
    KeyWriter(KeyWriter&&);
};

/**
 * The filtered writer to write data elements whose key match a given filter.
 */
template<typename Key, typename Value> class FilteredWriter : public Writer<Key, Value>
{
public:

    /**
     * Construct a new writer for the given filter. The construction of the writer
     * connects the writer to readers whose key matches the filter.
     *
     * @param topic The topic writer.
     * @param filter The filter.
     */
    template<typename Filter>
    FilteredWriter(Topic<Key, Value, Filter>&, const typename Filter::FilterType&);

    /**
     * Transfers the given writer to this writer.
     *
     * @param writer The writer.
     **/
    FilteredWriter(FilteredWriter&&);
};

}


//
// Public template based API implementation
//

namespace DataStorm
{

//
// Encoder template implementation
//
template<typename T> std::vector<unsigned char>
Encoder<T>::encode(const std::shared_ptr<Ice::Communicator>& communicator, const T& value)
{
    std::vector<unsigned char> v;
    Ice::OutputStream stream(communicator);
    stream.write(value);
    stream.finished(v);
    return v;
}

template<typename T> T
Encoder<T>::decode(const std::shared_ptr<Ice::Communicator>& communicator, const std::vector<unsigned char>& value)
{
    T v;
    if(value.empty())
    {
        v = T();
    }
    else
    {
        Ice::InputStream(communicator, value).read(v);
    }
    return v;
}

template<typename T> std::string
Stringifier<T>::toString(const T& value)
{
    return DataStormInternal::Stringifier<T>::toString(value);
}

//
// Sample template implementation
//
template<typename Key, typename Value> SampleType
Sample<Key, Value>::getType() const
{
    return _impl->type;
}

template<typename Key, typename Value> Key
Sample<Key, Value>::getKey() const
{
    return _impl->getKey();
}

template<typename Key, typename Value> Value
Sample<Key, Value>::getValue() const
{
    return _impl->getValue();
}

template<typename Key, typename Value> IceUtil::Time
Sample<Key, Value>::getTimestamp() const
{
    return IceUtil::Time::milliSeconds(_impl->timestamp);
}

template<typename Key, typename Value>
Sample<Key, Value>::Sample(const std::shared_ptr<DataStormInternal::Sample>& impl) :
    _impl(std::static_pointer_cast<DataStormInternal::SampleT<Key, Value>>(impl))
{
}

//
// Reader template implementation
//
template<typename Key, typename Value>
Reader<Key, Value>::~Reader()
{
    if(_impl)
    {
        _impl->destroy();
    }
}

template<typename Key, typename Value> bool
Reader<Key, Value>::hasWriters() const
{
    return _impl->hasWriters();
}

template<typename Key, typename Value> void
Reader<Key, Value>::waitForWriters(unsigned int count) const
{
    _impl->waitForWriters(count);
}

template<typename Key, typename Value> void
Reader<Key, Value>::waitForNoWriters() const
{
    _impl->waitForWriters(-1);
}

template<typename Key, typename Value> int
Reader<Key, Value>::getInstanceCount() const
{
    return _impl->getInstanceCount();
}

template<typename Key, typename Value> std::vector<Sample<Key, Value>>
Reader<Key, Value>::getAll() const
{
    auto all = _impl->getAll();
    std::vector<Sample<Key, Value>> samples;
    samples.reserve(all.size());
    for(const auto& sample : all)
    {
        samples.emplace_back(sample);
    }
    return samples;
}

template<typename Key, typename Value> std::vector<Sample<Key, Value>>
Reader<Key, Value>::getAllUnread()
{
    auto unread = _impl->getAllUnread();
    std::vector<Sample<Key, Value>> samples;
    samples.reserve(unread.size());
    for(auto sample : unread)
    {
        samples.emplace_back(sample);
    }
    return samples;
}

template<typename Key, typename Value> void
Reader<Key, Value>::waitForUnread(unsigned int count) const
{
    _impl->waitForUnread(count);
}

template<typename Key, typename Value> bool
Reader<Key, Value>::hasUnread() const
{
    return _impl->hasUnread();
}

template<typename Key, typename Value> Sample<Key, Value>
Reader<Key, Value>::getNextUnread()
{
    return Sample<Key, Value>(_impl->getNextUnread());
}

template<typename Key, typename Value> template<typename Filter>
KeyReader<Key, Value>::KeyReader(Topic<Key, Value, Filter>& topic, const Key& key) :
    Reader<Key, Value>(topic.getReader()->createDataReader({ topic._keyFactory->create(key) }))
{
}

template<typename Key, typename Value> template<typename Filter>
KeyReader<Key, Value>::KeyReader(Topic<Key, Value, Filter>& topic, const std::vector<Key>& keys) :
    Reader<Key, Value>(topic.getReader()->createDataReader(topic._keyFactory->create(keys)))
{
}

template<typename Key, typename Value>
KeyReader<Key, Value>::KeyReader(KeyReader<Key, Value>&& reader) :
    Reader<Key, Value>(std::move(reader))
{
}

template<typename Key, typename Value> template<typename Filter>
FilteredReader<Key, Value>::FilteredReader(Topic<Key, Value, Filter>& topic,
                                           const typename Filter::FilterType& filter) :
    Reader<Key, Value>(topic.getReader()->createFilteredDataReader(topic._filterFactory->create(filter)))
{
}

template<typename Key, typename Value>
FilteredReader<Key, Value>::FilteredReader(FilteredReader<Key, Value>&& reader) :
    Reader<Key, Value>(std::move(reader))
{
}

//
// Writer template implementation
//
template<typename Key, typename Value>
Writer<Key, Value>::~Writer()
{
    if(_impl)
    {
        _impl->destroy();
    }
}

template<typename Key, typename Value> bool
Writer<Key, Value>::hasReaders() const
{
    return _impl->hasReaders();
}

template<typename Key, typename Value> void
Writer<Key, Value>::waitForReaders(unsigned int count) const
{
    return _impl->waitForReaders(count);
}

template<typename Key, typename Value> void
Writer<Key, Value>::waitForNoReaders() const
{
    return _impl->waitForReaders(-1);
}

template<typename Key, typename Value> void
Writer<Key, Value>::add(const Value& value)
{
    _impl->publish(std::make_shared<DataStormInternal::SampleT<Key, Value>>(SampleType::Add, value));
}

template<typename Key, typename Value> void
Writer<Key, Value>::update(const Value& value)
{
    _impl->publish(std::make_shared<DataStormInternal::SampleT<Key, Value>>(SampleType::Update, value));
}

template<typename Key, typename Value> void
Writer<Key, Value>::remove()
{
    _impl->publish(std::make_shared<DataStormInternal::SampleT<Key, Value>>(SampleType::Remove, Value()));
}

template<typename Key, typename Value> template<typename Filter>
KeyWriter<Key, Value>::KeyWriter(Topic<Key, Value, Filter>& topic, const Key& key) :
    Writer<Key, Value>(topic.getWriter()->createDataWriter({ topic._keyFactory->create(key) }))
{
}

template<typename Key, typename Value> template<typename Filter>
KeyWriter<Key, Value>::KeyWriter(Topic<Key, Value, Filter>& topic, const std::vector<Key>& keys) :
    Writer<Key, Value>(topic.getWriter()->createDataWriter(topic._keyFactory->create(keys)))
{
}

template<typename Key, typename Value>
KeyWriter<Key, Value>::KeyWriter(KeyWriter<Key, Value>&& writer) :
    Writer<Key, Value>(std::move(writer))
{
}

template<typename Key, typename Value> template<typename Filter>
FilteredWriter<Key, Value>::FilteredWriter(Topic<Key, Value, Filter>& topic,
                                                   const typename Filter::FilterType& filter) :
    Writer<Key, Value>(topic.getWriter()->createFilteredDataWriter(topic._filterFactory->create(filter)))
{
}

template<typename Key, typename Value>
FilteredWriter<Key, Value>::FilteredWriter(FilteredWriter<Key, Value>&& writer) :
    Writer<Key, Value>(std::move(writer))
{
}

//
// Topic template implementation
//
template<typename Key, typename Value, typename Filter>
Topic<Key, Value, Filter>::Topic(Node& node, const std::string& name) :
    _name(name),
    _topicFactory(node._factory),
    _keyFactory(DataStormInternal::KeyFactoryT<Key>::createFactory()),
    _filterFactory(DataStormInternal::FilterFactoryT<Key, Value, Filter>::createFactory())
{
}

template<typename Key, typename Value, typename Filter>
Topic<Key, Value, Filter>::Topic(Topic<Key, Value, Filter>&& topic) :
    _topicFactory(topic._topicFactory),
    _reader(std::move(topic._reader)),
    _writer(std::move(topic._writer)),
    _keyFactory(std::move(topic._keyFactory)),
    _filterFactory(std::move(topic._filterFactory))
{
}

template<typename Key, typename Value, typename Filter>
Topic<Key, Value, Filter>::~Topic()
{
    std::lock_guard<std::mutex> lock(_mutex);
    if(_reader)
    {
        _reader->destroy();
    }
    if(_writer)
    {
        _writer->destroy();
    }
}

template<typename Key, typename Value, typename Filter> bool
Topic<Key, Value, Filter>::hasWriters() const
{
    return getReader()->hasWriters();
}

template<typename Key, typename Value, typename Filter> void
Topic<Key, Value, Filter>::waitForWriters(unsigned int count) const
{
    getReader()->waitForWriters(count);
}

template<typename Key, typename Value, typename Filter> void
Topic<Key, Value, Filter>::waitForNoWriters() const
{
    getReader()->waitForWriters(-1);
}

template<typename Key, typename Value, typename Filter> bool
Topic<Key, Value, Filter>::hasReaders() const
{
    return getWriter()->hasReaders();
}

template<typename Key, typename Value, typename Filter> void
Topic<Key, Value, Filter>::waitForReaders(unsigned int count) const
{
    getWriter()->waitForReaders(count);
}

template<typename Key, typename Value, typename Filter> void
Topic<Key, Value, Filter>::waitForNoReaders() const
{
    getWriter()->waitForReaders(-1);
}

template<typename Key, typename Value, typename Filter> std::shared_ptr<DataStormInternal::TopicReader>
Topic<Key, Value, Filter>::getReader() const
{
    std::lock_guard<std::mutex> lock(_mutex);
    if(!_reader)
    {
        _reader = _topicFactory->createTopicReader(_name,
                                                   _keyFactory,
                                                   _filterFactory,
                                                   DataStormInternal::SampleT<Key, Value>::factory());
    }
    return _reader;
}

template<typename Key, typename Value, typename Filter> std::shared_ptr<DataStormInternal::TopicWriter>
Topic<Key, Value, Filter>::getWriter() const
{
    std::lock_guard<std::mutex> lock(_mutex);
    if(!_writer)
    {
        _writer = _topicFactory->createTopicWriter(_name,
                                                   _keyFactory,
                                                   _filterFactory,
                                                   DataStormInternal::SampleT<Key, Value>::factory());
    }
    return _writer;
}

}