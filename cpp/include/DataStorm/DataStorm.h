// **********************************************************************
//
// Copyright (c) 2003-2017 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************

#pragma once

#include <DataStorm/Config.h>

#include <Ice/Communicator.h>
#include <Ice/Initialize.h>
#include <Ice/InputStream.h>
#include <Ice/OutputStream.h>

#include <DataStorm/Types.h>
#include <DataStorm/Sample.h>
#include <DataStorm/Node.h>
#include <DataStorm/InternalI.h>
#include <DataStorm/InternalT.h>

#include <regex>

/**
 * \mainpage %DataStorm API Reference
 *
 * \section namespaces Namespaces
 *
 * @ref DataStorm â€” The %DataStorm core library.
 */
namespace DataStorm
{

template<typename, typename, typename> class Reader;
template<typename, typename, typename> class Writer;
template<typename, typename, typename, typename> class KeyReader;
template<typename, typename, typename, typename, typename> class KeyWriter;
template<typename, typename, typename, typename> class FilteredReader;

/**
 * A sample provides information about an update of a data element.
 *
 * The Sample template provides access to key, value and type of
 * an update to a data element.
 */
template<typename Key, typename Value> class Sample
{
public:

    using KeyType = Key;
    using ValueType = Value;

    /**
     * The event of the sample.
     *
     * @return The sample event.
     */
    SampleEvent getEvent() const;

    /**
     * The key of the sample.
     *
     * @return The sample key.
     */
    Key getKey() const;

    /**
     * The value of the sample.
     *
     * Depending on the sample type, the sample value might not always be
     * available. It is for instance the case if the sample type is Remove.
     *
     * @return The sample value.
     */
    Value getValue() const;

    /**
     * The timestamp of the sample.
     *
     * The timestamp is generated by the writer. It corresponds to time at
     * which the sample was sent.
     *
     * @return The timestamp.
     */
    std::chrono::time_point<std::chrono::system_clock> getTimeStamp() const;

    /**
     * The origin of the sample.
     *
     * The origin of the sample identifies uniquely on the node the writer
     * that created the sample. It's a tupple composed of the node session
     * identity, the topic and writer opaque identifiers.
     *
     * @return The tuple that uniquely identifies on the node the origin
     *         of the sample.
     */
    std::tuple<std::string, long long int, long long int> getOrigin() const;

    /** @private */
    Sample(const std::shared_ptr<DataStormInternal::Sample>&);

private:

    std::shared_ptr<DataStormInternal::SampleT<Key, Value>> _impl;
};

/**
 * The RegexKeyFilter template filters keys matching a regular expression.
 **/
#if defined(__GNUC__) && defined(__GXX_EXPERIMENTAL_CXX0X__) && ((__GNUC__* 100) + __GNUC_MINOR__) < 490

#include <regex.h>

template<typename T>
class RegexFilter
{
public:

    /**
     * Construct the filter with the given filter criteria.
     *
     * @param criteria The filter criteria.
     */
    RegexFilter(const std::string& criteria)
    {
        if(regcomp(&_regex, criteria.c_str(), REG_EXTENDED) != 0)
        {
            throw std::invalid_argument(criteria);
        }
    }

    /**
     * Returns wether or not the value matches the regular expression.
     *
     * @param value The value to match against the regular expression.
     * @return True if the value matches the regular expression, false otherwise.
     */
    bool match(const T& value) const
    {
        std::ostringstream os;
        os << value;
        return regexec(&_regex, os.str().c_str(), 0, 0, 0) == 0;
    }

private:

    regex_t _regex;
};

#else

template<typename T>
class RegexFilter
{
public:

    /**
     * Construct the filter with the given filter criteria.
     *
     * @param criteria The filter criteria.
     */
    RegexFilter(const std::string& criteria) : _regex(criteria)
    {
    }

    /**
     * Returns wether or not the value matches the regular expression.
     *
     * @param value The value to match against the regular expression.
     * @return True if the value matches the regular expression, false otherwise.
     */
    bool match(const T& value) const
    {
        std::ostringstream os;
        os << value;
        return std::regex_match(os.str(), _regex);
    }

private:

    std::regex _regex;
};

#endif


/**
 * The SampleEventFilter template filters samples based on a set of sample types.
 **/
template<typename Key, typename Value> struct SampleEventFilter
{
public:

    /**
     * Construct the filter with the given types criteria.
     *
     * @param criteria The filter criteria.
     */
    SampleEventFilter(std::vector<SampleEvent> criteria) : _events(std::move(criteria))
    {
    }

    /**
     * Returns wether or not the sample matches the sample types.
     *
     * @param sample The sample to match against the filter.
     * @return True if the sample type matches the filter sample types, false otherwise.
     */
    bool match(const Sample<Key, Value>& sample) const
    {
        return std::find(_events.begin(), _events.end(), sample.getEvent()) != _events.end();
    }

private:

    const std::vector<SampleEvent> _events;
};

std::ostream&
operator<<(std::ostream& os, SampleEvent sampleType)
{
    switch(sampleType)
    {
    case SampleEvent::Add:
        os << "Add";
        break;
    case SampleEvent::Update:
        os << "Update";
        break;
    case SampleEvent::Remove:
        os << "Remove";
        break;
    default:
        os << static_cast<int>(sampleType);
        break;
    }
    return os;
}

std::ostream&
operator<<(std::ostream& os, const std::vector<SampleEvent>& types)
{
    os << "[";
    for(auto p = types.begin(); p != types.end(); ++p)
    {
        if(p != types.begin())
        {
            os << ',';
        }
        os << *p;
    }
    os << "]";
    return os;
}

template<typename K, typename V>
std::ostream&
operator<<(std::ostream& os, const Sample<K, V>& sample)
{
    os << sample.getValue();
    return os;
}

/**
 * The Topic class allows to construct Reader and Writer objects.
 */
template<typename Key,
         typename Value,
         typename KeyFilter=void,
         typename KeyFilterCriteria=void,
         typename UpdateTag=std::string>
class Topic
{
public:

    using KeyType = Key;
    using ValueType = Value;
    using KeyFilterType = KeyFilter;
    using KeyFilterCriteriaType = KeyFilterCriteria;
    using UpdateTagType = UpdateTag;

    using WriterType = Writer<Key, Value, UpdateTag>;
    using ReaderType = Reader<Key, Value, UpdateTag>;

    /**
     * Construct a new Topic for the topic with the given name.
     *
     * @param node The DataStorm node
     * @param name The name of the topic
     */
    Topic(Node&, const std::string&);

    /**
     * Construct a new Topic by taking ownership of the given topic.
     *
     * @param topic The topic to transfer ownership from.
     */
    Topic(Topic&&);

    /**
     * Destruct the Topic. This disconnects the topic from peers.
     */
    ~Topic();

    /**
     * Indicates whether or not topic writers are online.
     *
     * @return True if topic writers are connected, false otherwise.
     */
    bool hasWriters() const;

    /**
     * Wait for given number of topic writers to be online.
     *
     * @param count The number of topic writers to wait.
     */
    void waitForWriters(unsigned int = 1) const;

    /**
     * Wait for topic writers to be offline.
     */
    void waitForNoWriters() const;

    /**
     * Set the default configuration used to construct readers.
     *
     * @param config The default writer configuration.
     */
    void setWriterDefaultConfig(WriterConfig);

    /**
     * Indicates whether or not topic readers are online.
     *
     * @return True if topic readers are connected, false otherwise.
     */
    bool hasReaders() const;

    /**
     * Wait for given number of topic readers to be online.
     *
     * @param count The number of topic readers to wait.
     */
    void waitForReaders(unsigned int = 1) const;

    /**
     * Wait for topic readers to be offline.
     */
    void waitForNoReaders() const;

    /**
     * Set the default configuration used to construct readers.
     *
     * @param config The default reader configuration.
     */
    void setReaderDefaultConfig(ReaderConfig);

    /**
     * Set an updater function for the given update tag. The function is called
     * when a partial update is received or sent to update the latest value. The
     * function is provided the latest value and partial update and it should
     * return the new value.
     *
     * @param tag The update tag.
     * @param updater The updater function.
     */
    template<typename UpdateValue>
    void setUpdater(const UpdateTag&, std::function<void (Value&, UpdateValue)>);

private:

    std::shared_ptr<DataStormInternal::TopicReader> getReader() const;
    std::shared_ptr<DataStormInternal::TopicWriter> getWriter() const;
    std::shared_ptr<Ice::Communicator> getCommunicator() const;

    template<typename, typename, typename, typename, typename> friend class KeyWriter;
    template<typename, typename, typename, typename> friend class KeyReader;
    template<typename, typename, typename, typename, typename> friend class MultiKeyWriter;
    template<typename, typename, typename, typename> friend class MultiKeyReader;
    template<typename, typename, typename, typename> friend class FilteredReader;

    const std::string _name;
    const std::shared_ptr<DataStormInternal::TopicFactory> _topicFactory;
    const std::shared_ptr<DataStormInternal::KeyFactoryT<Key>> _keyFactory;
    const std::shared_ptr<DataStormInternal::FilterFactoryT<KeyFilter,
                                                            KeyFilterCriteria,
                                                            DataStormInternal::KeyT<Key>>> _filterFactory;
    const std::shared_ptr<DataStormInternal::TagFactoryT<UpdateTag>> _tagFactory;

    mutable std::mutex _mutex;
    mutable std::shared_ptr<DataStormInternal::TopicReader> _reader;
    mutable std::shared_ptr<DataStormInternal::TopicWriter> _writer;
    mutable std::map<std::shared_ptr<DataStormInternal::Tag>, DataStormInternal::Topic::Updater> _updaters;
};

/**
 * The Reader class is used to retrieve samples for a data element.
 */
template<typename Key, typename Value, typename UpdateTag>
class Reader
{
public:

    using KeyType = Key;
    using ValueType = Value;

    /**
     * Transfers the given reader to this reader.
     *
     * @param reader The reader.
     **/
    Reader(Reader&& reader) : _impl(std::move(reader._impl))
    {
    }

    /**
     * Destruct the reader. The destruction of the reader disconnects
     * the reader from the writers.
     */
    ~Reader();

    /**
     * Indicates whether or not writers are online.
     *
     * @return True if writers are connected, false otherwise.
     */
    bool hasWriters() const;

    /**
     * Wait for given number of writers to be online.
     *
     * @param count The number of writers to wait.
     */
    void waitForWriters(unsigned int = 1) const;

    /**
     * Wait for readers to be offline.
     */
    void waitForNoWriters() const;

    /**
     * Returns all the data samples available with this reader.
     *
     * @return The data samples.
     */
    std::vector<Sample<Key, Value>> getAll() const;

    /**
     * Returns all the unread data samples.
     *
     * @return The unread data samples.
     */
    std::vector<Sample<Key, Value>> getAllUnread();

    /**
     * Wait for given number of unread data samples to be available.
     */
    void waitForUnread(unsigned int = 1) const;

    /**
     * Returns wether or not data unread data samples are available.
     */
    bool hasUnread() const;

    /**
     * Returns the next unread data sample.
     *
     * @return The unread data sample.
     */
    Sample<Key, Value> getNextUnread();

    /**
     * Calls the given lambda when a new writer connects to this reader.
     *
     * @param callback The lambda to call when a new reader connects. The tuple
     *                 provided to the lambda indentifies the writer.
     *
     * @see Sample<K, V>::getOrigin
     **/
    void onConnect(std::function<void(std::tuple<std::string, long long int, long long int>)>);

    /**
     * Calls the given lambda when a new writer disconnects from this reader.
     *
     * @param callback The lambda to call when a new reader disconnects. The tuple
     *                 provided to the lambda indentifies the writer.
     *
     * @see Sample<K, V>::getOrigin
     **/
    void onDisconnect(std::function<void(std::tuple<std::string, long long int, long long int>)>);

    /**
     * Calls the given lambda when a writer connects and provides its initialization
     * samples. If a lambda is already set, it will be replaced with this new lambda.
     *
     * @param callback The lambda to call when initialization samples are received.
     **/
    void onInit(std::function<void(std::vector<Sample<Key, Value>>)>);

    /**
     * Calls the given lambda when a sample is queued with this reader. If
     * a lambda is already set, it will be replaced with this new lambda.
     *
     * @param callback The lambda to call when a sample is queued.
     **/
    void onSample(std::function<void(Sample<Key, Value>)>);

protected:

    /** @private */
    Reader(const std::shared_ptr<DataStormInternal::DataReader>& impl) : _impl(impl)
    {
    }

    std::shared_ptr<DataStormInternal::DataReader> _impl;
};

/**
 * The key reader to read the data element associated with a given key.
 */
template<typename Key, typename Value, typename SampleFilterCriteria, typename UpdateTag=std::string>
class KeyReader : public Reader<Key, Value, UpdateTag>
{
public:

    /**
     * Construct a new reader for the given key. The construction of the reader
     * connects the reader to writers with a matching key.
     *
     * @param topic The topic.
     * @param key The key of the data element to read.
     * @param config The reader configuration.
     */
    template<typename KeyFilter, typename KeyFilterCriteria>
    KeyReader(Topic<Key, Value, KeyFilter, KeyFilterCriteria, UpdateTag>&,
              Key,
              ReaderConfig = ReaderConfig());

    /**
     * Construct a new reader for the given key and sample filter criteria. The
     * construction of the reader connects the reader to writers with a matching key.
     *
     * @param topic The topic.
     * @param key The key of the data element to read.
     * @param criteria The sample filter criteria used by writers to filter the samples.
     * @param config The reader configuration.
     */
    template<typename KeyFilter, typename KeyFilterCriteria>
    KeyReader(Topic<Key, Value, KeyFilter, KeyFilterCriteria, UpdateTag>&,
              Key,
              SampleFilterCriteria,
              ReaderConfig = ReaderConfig());

    /**
     * Transfers the given reader to this reader.
     *
     * @param reader The reader.
     **/
    KeyReader(KeyReader&&);
};

/**
 * The key reader to read the data element associated with a given set of keys.
 */
template<typename Key, typename Value, typename SampleFilterCriteria, typename UpdateTag=std::string>
class MultiKeyReader : public Reader<Key, Value, UpdateTag>
{
public:

    /**
     * Construct a new reader for the given keys. The construction of the reader
     * connects the reader to writers with matching keys.
     *
     * @param topic The topic.
     * @param keys The keys of the data elements to read.
     * @param config The reader configuration.
     */
    template<typename KeyFilter, typename KeyFilterCriteria>
    MultiKeyReader(Topic<Key, Value, KeyFilter, KeyFilterCriteria, UpdateTag>&,
                   std::vector<Key>,
                   ReaderConfig = ReaderConfig());

    /**
     * Construct a new reader for the given keys and sample filter criteria. The
     * construction of the reader connects the reader to writers with matching keys.
     *
     * @param topic The topic reader.
     * @param keys The keys of the data elements to read.
     * @param criteria The sample filter criteria used by writers to filter the samples.
     * @param config The reader configuration.
     */
    template<typename KeyFilter, typename KeyFilterCriteria>
    MultiKeyReader(Topic<Key, Value, KeyFilter, KeyFilterCriteria, UpdateTag>&,
                   std::vector<Key>,
                   SampleFilterCriteria,
                   ReaderConfig = ReaderConfig());

    /**
     * Transfers the given reader to this reader.
     *
     * @param reader The reader.
     **/
    MultiKeyReader(MultiKeyReader&&);
};

/**
 * Creates a key reader for the given topic. This helper method deduces the
 * topic Key and Value types from the topic argument.
 *
 * @param topic The topic.
 * @param key The key.
 * @param config The optional reader configuration.
 */
template<typename K, typename V, typename KF, typename KFC, typename UT>
    KeyReader<K, V, void, UT>
makeSingleKeyReader(Topic<K, V, KF, KFC, UT>& topic,
                    typename Topic<K, V, KF, KFC, UT>::KeyType key,
                    ReaderConfig config = ReaderConfig())
{
    return KeyReader<K, V, void, UT>(topic, key, config);
}

/**
 * Creates a key reader for the given topic and using the given sample filter
 * criteria type. This helper method deduces the topic Key and Value types from the
 * topic argument.
 *
 * @param topic The topic.
 * @param key The key.
 * @param sampleFilterCriteria The sample filter criteria.
 * @param config The optional reader configuration.
 */
template<typename SFC, typename K, typename V, typename KF, typename KFC, typename UT>
KeyReader<K, V, SFC, UT>
makeSingleKeyReader(Topic<K, V, KF, KFC, UT>& topic,
                    typename Topic<K, V, KF, KFC, UT>::KeyType key,
                    SFC sampleFilterCriteria,
                    ReaderConfig config = ReaderConfig())
{
    return KeyReader<K, V, SFC, UT>(topic, key, sampleFilterCriteria, config);
}

/**
 * Creates a multi-key reader for the given topic. This helper method deduces the
 * topic Key and Value types from the topic argument.
 *
 * The reader will only receive samples for the set for the given set of keys.
 *
 * @param topic The topic.
 * @param keys The keys.
 * @param config The optional reader configuration.
 */
template<typename K, typename V, typename KF, typename KFC, typename UT>
MultiKeyReader<K, V, void, UT>
makeMultiKeyReader(Topic<K, V, KF, KFC, UT>& topic,
                   std::vector<typename Topic<K, V, KF, KFC, UT>::KeyType> keys,
                   ReaderConfig config = ReaderConfig())
{
    return MultiKeyReader<K, V, void, UT>(topic, keys, config);
}

/**
 * Creates a multi-key reader for the given topic and using the given sample filter
 * criteria type. This helper method deduces the topic Key and Value types from the
 * topic argument.
 *
 * The reader will only receive samples for the set for the given set of keys.
 *
 * @param topic The topic.
 * @param keys The keys.
 * @param sampleFilterCriteria The sample filter criteria.
 * @param config The optional reader configuration.
 */
template<typename SFC, typename K, typename V, typename KF, typename KFC, typename UT>
MultiKeyReader<K, V, SFC, UT>
makeMultiKeyReader(Topic<K, V, KF, KFC, UT>& topic,
                   std::vector<typename Topic<K, V, KF, KFC, UT>::KeyType> keys,
                   SFC sampleFilterCriteria,
                   ReaderConfig config = ReaderConfig())
{
    return MultiKeyReader<K, V, SFC, UT>(topic, keys, sampleFilterCriteria, config);
}

/**
 * Creates an any-key reader for the given topic. This helper method deduces the
 * topic Key and Value types from the topic argument.
 *
 * The reader will receive samples for the keys from the topic.
 *
 * @param topic The topic.
 * @param config The optional reader configuration.
 */
template<typename K, typename V, typename KF, typename KFC, typename UT>
MultiKeyReader<K, V, void, UT>
makeAnyKeyReader(Topic<K, V, KF, KFC, UT>& topic, ReaderConfig config = ReaderConfig())
{
    return MultiKeyReader<K, V, void, UT>(topic, {}, config);
}

/**
 * Creates an any-key reader for the given topic and using the given sample filter
 * criteria type. This helper method deduces the topic Key and Value types from the
 * topic argument.
 *
 * The reader will receive samples for the keys from the topic.
 *
 * @param topic The topic.
 * @param sampleFilterCriteria The sample filter criteria.
 * @param config The optional reader configuration.
 */
template<typename SFC, typename K, typename V, typename KF, typename KFC, typename UT>
MultiKeyReader<K, V, SFC, UT>
makeAnyKeyReader(Topic<K, V, KF, KFC, UT>& topic, SFC sampleFilterCriteria, ReaderConfig config = ReaderConfig())
{
    return MultiKeyReader<K, V, SFC, UT>(topic, {}, sampleFilterCriteria, config);
}

/**
 * Key reader template specialization for key readers with no sample filter.
 */
template<typename Key, typename Value, typename UpdateTag>
class KeyReader<Key, Value, void, UpdateTag> : public Reader<Key, Value, UpdateTag>
{
public:

    /**
     * Construct a new reader for the given key. The construction of the reader
     * connects the reader to writers with a matching key.
     *
     * @param topic The topic.
     * @param key The key of the data element to read.
     * @param config The reader configuration.
     */
    template<typename KeyFilter, typename KeyFilterCriteria>
    KeyReader(Topic<Key, Value, KeyFilter, KeyFilterCriteria, UpdateTag>&, Key, ReaderConfig = ReaderConfig());

    /**
     * Transfers the given reader to this reader.
     *
     * @param reader The reader.
     **/
    KeyReader(KeyReader<Key, Value, void, UpdateTag>&&);
};

/**
 * Key reader template specialization for key readers with no sample filter.
 */
template<typename Key, typename Value, typename UpdateTag>
class MultiKeyReader<Key, Value, void, UpdateTag> : public Reader<Key, Value, UpdateTag>
{
public:

    /**
     * Construct a new reader for the given keys. The construction of the reader
     * connects the reader to writers with matching keys.
     *
     * @param topic The topic.
     * @param keys The keys.
     * @param config The reader configuration.
     */
    template<typename KeyFilter, typename KeyFilterCriteria>
    MultiKeyReader(Topic<Key, Value, KeyFilter, KeyFilterCriteria, UpdateTag>&,
                   std::vector<Key>,
                   ReaderConfig = ReaderConfig());

    /**
     * Transfers the given reader to this reader.
     *
     * @param reader The reader.
     **/
    MultiKeyReader(MultiKeyReader<Key, Value, void, UpdateTag>&&);
};

/**
 * The filtered reader to read data elements whose key match a given filter.
 */
template<typename Key, typename Value, typename SampleFilterCriteria, typename UpdateTag=std::string>
class FilteredReader : public Reader<Key, Value, UpdateTag>
{
public:

    /**
     * Construct a new reader for the given key filter. The construction of the reader
     * connects the reader to writers whose key matches the key filter criteria.
     *
     * @param topic The topic.
     * @param criteria The filter criteria.
     * @param config The reader configuration.
     */
    template<typename KeyFilter, typename KeyFilterCriteria>
    FilteredReader(Topic<Key, Value, KeyFilter, KeyFilterCriteria, UpdateTag>&,
                   typename Topic<Key, Value, KeyFilter, KeyFilterCriteria, UpdateTag>::KeyFilterCriteriaType,
                   ReaderConfig = ReaderConfig());

    /**
     * Construct a new reader for the given key filter and sample filter criterias. The
     * construction of the reader connects the reader to writers whose key matches the
     * key filter criteria.
     *
     * @param topic The topic.
     * @param criteria The key filter criteria used by writers to filter the key.
     * @param sampleCriteria The sample filter criteria used by writers to filter the samples
     * @param config The reader configuration.
     */
    template<typename KeyFilter, typename KeyFilterCriteria>
    FilteredReader(Topic<Key, Value, KeyFilter, KeyFilterCriteria, UpdateTag>&,
                   typename Topic<Key, Value, KeyFilter, KeyFilterCriteria, UpdateTag>::KeyFilterCriteriaType,
                   SampleFilterCriteria,
                   ReaderConfig = ReaderConfig());

    /**
     * Transfers the given reader to this reader.
     *
     * @param reader The reader.
     **/
    FilteredReader(FilteredReader&&);
};

/**
 * Creates a new reader for the given topic and key filter. This helper method deduces
 * the topic Key and Value types from the topic argument.
 *
 * @param topic The topic.
 * @param filter The key filter criteria.
 * @param config The optional reader configuration.
 */
template<typename K, typename V, typename KF, typename KFC, typename UT>
FilteredReader<K, V, void, UT>
makeFilteredReader(Topic<K, V, KF, KFC, UT>& topic,
                   typename Topic<K, V, KF, KFC, UT>::KeyFilterCriteriaType filter,
                   ReaderConfig config = ReaderConfig())
{
    return FilteredReader<K, V, void, UT>(topic, filter, config);
}

/**
 * Creates a new reader for the given topic, key filter and sample criteria. This helper
 * method deduces the topic Key and Value types from the topic argument.
 *
 * @param topic The topic.
 * @param filter The key filter criteria.
 * @param sampleFilterCriteria The sample filter criteria.
 * @param config The optional reader configuration.
 */
template<typename SFC, typename K, typename V, typename KF, typename KFC, typename UT>
FilteredReader<K, V, SFC, UT>
makeFilteredReader(Topic<K, V, KF, KFC, UT>& topic,
                   typename Topic<K, V, KF, KFC, UT>::KeyFilterCriteriaType filter,
                   SFC sampleFilterCriteria,
                   ReaderConfig config = ReaderConfig())
{
    return FilteredReader<K, V, SFC, UT>(topic, filter, sampleFilterCriteria, config);
}

/**
 * Filtered reader template specialization for filtered readers with no sample filter.
 */
template<typename Key, typename Value, typename UpdateTag>
class FilteredReader<Key, Value, void, UpdateTag> : public Reader<Key, Value, UpdateTag>
{
public:

    /**
     * Construct a new reader for the given key filter. The construction of the reader
     * connects the reader to writers whose key matches the key filter criteria.
     *
     * @param topic The topic.
     * @param criteria The filter criteria.
     * @param config The reader configuration.
     */
    template<typename KeyFilter, typename KeyFilterCriteria>
    FilteredReader(Topic<Key, Value, KeyFilter, KeyFilterCriteria, UpdateTag>&,
                   typename Topic<Key, Value, KeyFilter, KeyFilterCriteria, UpdateTag>::KeyFilterCriteriaType,
                   ReaderConfig = ReaderConfig());

    /**
     * Transfers the given reader to this reader.
     *
     * @param reader The reader.
     **/
    FilteredReader(FilteredReader<Key, Value, void, UpdateTag>&&);
};

/**
 * The Writer class is used to write samples for a data element.
 */
template<typename Key, typename Value, typename UpdateTag>
class Writer
{
public:

    using KeyType = Key;
    using ValueType = Value;

    /**
     * Transfers the given writer to this writer.
     *
     * @param writer The writer.
     **/
    Writer(Writer&& writer) : _impl(std::move(writer._impl))
    {
    }

    /**
     * Destruct the writer. The destruction of the writer disconnects
     * the writer from the readers.
     */
    ~Writer();

    /**
     * Indicates whether or not readers are online.
     *
     * @return True if readers are connected, false otherwise.
     */
    bool hasReaders() const;

    /**
     * Wait for given number of readers to be online.
     *
     * @param count The number of readers to wait.
     */
    void waitForReaders(unsigned int = 1) const;

    /**
     * Wait for readers to be offline.
     */
    void waitForNoReaders() const;

    /**
     *
     * Calls the given lambda when a new reader connects to this writer.
     *
     * @param callback The lambda to call when a new writer connects. The tuple
     *                 provided to the lambda indentifies the reader.
     *
     * @see Sample<K, V>::getOrigin
     **/
    void onConnect(std::function<void(std::tuple<std::string, long long int, long long int>)>);

    /**
     *
     * Calls the given lambda when a new reader disconnects from this writer.
     *
     * @param callback The lambda to call when a new writer disconnects. The tuple
     *                 provided to the lambda indentifies the reader.

     * @see Sample<K, V>::getOrigin
     **/
    void onDisconnect(std::function<void(std::tuple<std::string, long long int, long long int>)>);

protected:

    /** @private */
    Writer(const std::shared_ptr<DataStormInternal::DataWriter>& impl) : _impl(impl)
    {
    }

    std::shared_ptr<DataStormInternal::DataWriter> _impl;
};

/**
 * The key writer to write the data element associated with a given key.
 */
template<typename Key, typename Value, typename SampleFilter=void, typename SampleFilterCriteria=void,
         typename UpdateTag=std::string>
class KeyWriter : public Writer<Key, Value, UpdateTag>
{
public:

    /**
     * Construct a new writer for the given key. The construction of the writer
     * connects the writer to readers with a matching key.
     *
     * @param topic The topic.
     * @param key The key of the data element to write.
     * @param config The writer configuration.
     */
    template<typename KeyFilter, typename KeyFilterCriteria>
    KeyWriter(Topic<Key, Value, KeyFilter, KeyFilterCriteria, UpdateTag>&, Key, WriterConfig = WriterConfig());

    /**
     * Transfers the given writer to this writer.
     *
     * @param writer The writer.
     **/
    KeyWriter(KeyWriter&&);

    /**
     * Add the data element. This generates an {@link Add} data sample with the
     * given value.
     *
     * @param value The data element value.
     */
    void add(const Value&);

    /**
     * Update the data element. This generates an {@link Update} data sample with the
     * given value.
     *
     * @param value The data element value.
     */
    void update(const Value&);

    /**
     * Partially update the data element. This generates a {@link PartialUpdate} data sample
     * with the given partial update value.
     *
     * @param tag The partial update tag.
     * @param value The partial update value.
     */
    template<typename UpdateValue>
    void update(const UpdateTag&, const UpdateValue&);

    /**
     * Remove the data element. This generates a {@link Remove} data sample.
     */
    void remove();

private:

    const std::shared_ptr<DataStormInternal::TagFactoryT<UpdateTag>> _tagFactory;
};

/**
 * The key writer to write data elements associated with a given set of keys.
 */
template<typename Key, typename Value, typename SampleFilter=void, typename SampleFilterCriteria=void,
         typename UpdateTag=std::string>
class MultiKeyWriter : public Writer<Key, Value, UpdateTag>
{
public:

    /**
     * Construct a new writer for the given key. The construction of the writer
     * connects the writer to readers with a matching key.
     *
     * @param topic The topic.
     * @param keys The keys.
     * @param config The writer configuration.
     */
    template<typename KeyFilter, typename KeyFilterCriteria>
    MultiKeyWriter(Topic<Key, Value, KeyFilter, KeyFilterCriteria, UpdateTag>&,
                   std::vector<Key>,
                   WriterConfig = WriterConfig());

    /**
     * Transfers the given writer to this writer.
     *
     * @param writer The writer.
     **/
    MultiKeyWriter(MultiKeyWriter&&);

    /**
     * Add the data element. This generates an {@link Add} data sample with the
     * given value.
     *
     * @param key The key
     * @param value The data element value.
     */
    void add(const Key&, const Value&);

    /**
     * Update the data element. This generates an {@link Update} data sample with the
     * given value.
     *
     * @param key The key
     * @param value The data element value.
     */
    void update(const Key&, const Value&);

    /**
     * Partially update the data element. This generates a {@link PartialUpdate} data sample
     * with the given partial update value.
     *
     * @param key The key
     * @param tag The partial update tag.
     * @param value The partial update value.
     */
    template<typename UpdateValue>
    void update(const Key&, const UpdateTag&, const UpdateValue&);

    /**
     * Remove the data element. This generates a {@link Remove} data sample.

     * @param key The key
     */
    void remove(const Key&);

private:

    const std::shared_ptr<DataStormInternal::KeyFactoryT<Key>> _keyFactory;
    const std::shared_ptr<DataStormInternal::TagFactoryT<UpdateTag>> _tagFactory;
};

/**
 * Creates a key writer for the given topic and using the given sample filter
 * and criteria types. This helper method deduces the topic Key and Value types from
 * the topic argument.
 *
 * @param topic The topic.
 * @param key The key.
 * @param config The optional writer configuration.
 */
template<typename SF, typename SFC, typename K, typename V, typename KF, typename KFC, typename UT>
KeyWriter<K, V, SF, SFC, UT>
makeSingleKeyWriter(Topic<K, V, KF, KFC, UT>& topic,
                    typename Topic<K, V, KF, KFC, UT>::KeyType key,
                    WriterConfig config = WriterConfig())
{
    return KeyWriter<K, V, SF, SFC, UT>(topic, key, config);
}

/**
 * Creates a key writer for the given topic. This helper method deduces
 * the topic Key and Value types from the topic argument.
 *
 * @param topic The topic.
 * @param key The key.
 * @param config The optional writer configuration.
 */
template<typename K, typename V, typename KF, typename KFC, typename UT>
KeyWriter<K, V, void, void, UT>
makeSingleKeyWriter(Topic<K, V, KF, KFC, UT>& topic,
                    typename Topic<K, V, KF, KFC, UT>::KeyType key,
                    WriterConfig config = WriterConfig())
{
    return KeyWriter<K, V, void, void, UT>(topic, key, config);
}

/**
 * Creates a multi-key writer for the given topic and using the given sample filter
 * and criteria types. This helper method deduces the topic Key and Value types from
 * the topic argument.
 *
 * @param topic The topic.
 * @param keys The keys.
 * @param config The optional writer configuration.
 */
template<typename SF, typename SFC, typename K, typename V, typename KF, typename KFC, typename UT>
KeyWriter<K, V, SF, SFC, UT>
makeMultiKeyWriter(Topic<K, V, KF, KFC, UT>& topic,
                   std::vector<typename Topic<K, V, KF, KFC, UT>::KeyType> keys,
                   WriterConfig config = WriterConfig())
{
    return MultiKeyWriter<K, V, SF, SFC, UT>(topic, keys, config);
}

/**
 * Creates a multi-key writer for the given topic. This helper method deduces
 * the topic Key and Value types from the topic argument.
 *
 * @param topic The topic.
 * @param keys The keys.
 * @param config The optional writer configuration.
 */
template<typename K, typename V, typename KF, typename KFC, typename UT>
KeyWriter<K, V, void, void, UT>
makeMultiKeyWriter(Topic<K, V, KF, KFC, UT>& topic,
                   std::vector<typename Topic<K, V, KF, KFC, UT>::KeyType> keys,
                   WriterConfig config = WriterConfig())
{
    return MultiKeyWriter<K, V, void, void, UT>(topic, keys, config);
}

/**
 * Creates an any-key writer for the given topic and using the given sample filter
 * and criteria types. This helper method deduces the topic Key and Value types from
 * the topic argument.
 *
 * @param topic The topic.
 * @param config The optional writer configuration.
 */
template<typename SF, typename SFC, typename K, typename V, typename KF, typename KFC, typename UT>
KeyWriter<K, V, SF, SFC, UT>
makeAnyKeyWriter(Topic<K, V, KF, KFC, UT>& topic, WriterConfig config = WriterConfig())
{
    return MultiKeyWriter<K, V, SF, SFC, UT>(topic, {}, config);
}

/**
 * Creates an any-key writer for the given topic. This helper method deduces
 * the topic Key and Value types from the topic argument.
 *
 * @param topic The topic.
 * @param config The optional writer configuration.
 */
template<typename K, typename V, typename KF, typename KFC, typename UT>
KeyWriter<K, V, void, void, UT>
makeAnyKeyWriter(Topic<K, V, KF, KFC, UT>& topic, WriterConfig config = WriterConfig())
{
    return MultiKeyWriter<K, V, void, void, UT>(topic, {}, config);
}

}


//
// Public template based API implementation
//

namespace DataStorm
{

//
// Sample template implementation
//
template<typename Key, typename Value> SampleEvent
Sample<Key, Value>::getEvent() const
{
    return _impl->event;
}

template<typename Key, typename Value> Key
Sample<Key, Value>::getKey() const
{
    return _impl->getKey();
}

template<typename Key, typename Value> Value
Sample<Key, Value>::getValue() const
{
    return _impl->getValue();
}

template<typename Key, typename Value> std::chrono::time_point<std::chrono::system_clock>
Sample<Key, Value>::getTimeStamp() const
{
    return _impl->timestamp;
}

template<typename Key, typename Value> std::tuple<std::string, long long int, long long int>
Sample<Key, Value>::getOrigin() const
{
    return std::make_tuple<std::string, long long int, long long int>(_impl->session, _impl->topic, _impl->element);
}

template<typename Key, typename Value> Sample<Key, Value>::Sample(const std::shared_ptr<DataStormInternal::Sample>& impl) :
    _impl(std::static_pointer_cast<DataStormInternal::SampleT<Key, Value>>(impl))
{
}

//
// Reader template implementation
//
template<typename Key, typename Value, typename UpdateTag>
Reader<Key, Value, UpdateTag>::~Reader()
{
    if(_impl)
    {
        _impl->destroy();
    }
}

template<typename Key, typename Value, typename UpdateTag> bool
Reader<Key, Value, UpdateTag>::hasWriters() const
{
    return _impl->hasWriters();
}

template<typename Key, typename Value, typename UpdateTag> void
Reader<Key, Value, UpdateTag>::waitForWriters(unsigned int count) const
{
    _impl->waitForWriters(count);
}

template<typename Key, typename Value, typename UpdateTag> void
Reader<Key, Value, UpdateTag>::waitForNoWriters() const
{
    _impl->waitForWriters(-1);
}

template<typename Key, typename Value, typename UpdateTag> std::vector<Sample<Key, Value>>
Reader<Key, Value, UpdateTag>::getAll() const
{
    auto all = _impl->getAll();
    std::vector<Sample<Key, Value>> samples;
    samples.reserve(all.size());
    for(const auto& sample : all)
    {
        samples.emplace_back(sample);
    }
    return samples;
}

template<typename Key, typename Value, typename UpdateTag> std::vector<Sample<Key, Value>>
Reader<Key, Value, UpdateTag>::getAllUnread()
{
    auto unread = _impl->getAllUnread();
    std::vector<Sample<Key, Value>> samples;
    samples.reserve(unread.size());
    for(auto sample : unread)
    {
        samples.emplace_back(sample);
    }
    return samples;
}

template<typename Key, typename Value, typename UpdateTag> void
Reader<Key, Value, UpdateTag>::waitForUnread(unsigned int count) const
{
    _impl->waitForUnread(count);
}

template<typename Key, typename Value, typename UpdateTag> bool
Reader<Key, Value, UpdateTag>::hasUnread() const
{
    return _impl->hasUnread();
}

template<typename Key, typename Value, typename UpdateTag> Sample<Key, Value>
Reader<Key, Value, UpdateTag>::getNextUnread()
{
    return Sample<Key, Value>(_impl->getNextUnread());
}

template<typename Key, typename Value, typename UpdateTag> void
Reader<Key, Value, UpdateTag>::onConnect(std::function<void(std::tuple<std::string, long long int, long long int>)> callback)
{
    _impl->onConnect(std::move(callback));
}

template<typename Key, typename Value, typename UpdateTag> void
Reader<Key, Value, UpdateTag>::onDisconnect(std::function<void(std::tuple<std::string, long long int, long long int>)> callback)
{
    _impl->onDisconnect(std::move(callback));
}

template<typename Key, typename Value, typename UpdateTag> void
Reader<Key, Value, UpdateTag>::onInit(std::function<void(std::vector<Sample<Key, Value>>)> callback)
{
    auto communicator = _impl->getCommunicator();
    _impl->onInit([communicator, callback](const std::vector<std::shared_ptr<DataStormInternal::Sample>>& samplesI)
    {
        std::vector<Sample<Key, Value>> samples;
        samples.reserve(samplesI.size());
        for(const auto& s : samplesI)
        {
            samples.emplace_back(s);
        }
        callback(move(samples));
    });
}

template<typename Key, typename Value, typename UpdateTag> void
Reader<Key, Value, UpdateTag>::onSample(std::function<void(Sample<Key, Value>)> callback)
{
    auto communicator = _impl->getCommunicator();
    _impl->onSample([communicator, callback](const std::shared_ptr<DataStormInternal::Sample>& sample)
    {
        callback(Sample<Key, Value>(sample));
    });
}

template<typename Key, typename Value, typename SampleFilterCriteria, typename UpdateTag>
template<typename KeyFilter, typename KeyFilterCriteria>
KeyReader<Key, Value, SampleFilterCriteria, UpdateTag>::KeyReader(
        Topic<Key, Value, KeyFilter, KeyFilterCriteria, UpdateTag>& topic,
        Key key,
        SampleFilterCriteria criteria,
        ReaderConfig config) :
    Reader<Key, Value, UpdateTag>(topic.getReader()->create({ topic._keyFactory->create(std::move(key)) },
                                                            std::move(config),
                                                            Encoder<SampleFilterCriteria>::encode(topic.getCommunicator(),
                                                                                                  criteria)))
{
}

template<typename Key, typename Value, typename SampleFilterCriteria, typename UpdateTag>
template<typename KeyFilter, typename KeyFilterCriteria>
KeyReader<Key, Value, SampleFilterCriteria, UpdateTag>::KeyReader(
        Topic<Key, Value, KeyFilter, KeyFilterCriteria, UpdateTag>& topic,
        Key key,
        ReaderConfig config) :
    Reader<Key, Value, UpdateTag>(topic.getReader()->create({ topic._keyFactory->create(std::move(key)) }, config))
{
}

template<typename Key, typename Value, typename SampleFilterCriteria, typename UpdateTag>
KeyReader<Key, Value, SampleFilterCriteria, UpdateTag>::KeyReader(
        KeyReader<Key, Value, SampleFilterCriteria, UpdateTag>&& reader) :
    Reader<Key, Value, UpdateTag>(std::move(reader))
{
}

template<typename Key, typename Value, typename SampleFilterCriteria, typename UpdateTag>
template<typename KeyFilter, typename KeyFilterCriteria>
MultiKeyReader<Key, Value, SampleFilterCriteria, UpdateTag>::MultiKeyReader(
        Topic<Key, Value, KeyFilter, KeyFilterCriteria, UpdateTag>& topic,
        std::vector<Key> keys,
        SampleFilterCriteria criteria,
        ReaderConfig config) :
    Reader<Key, Value, UpdateTag>(topic.getReader()->create(topic._keyFactory->create(std::move(keys)),
                                                            std::move(config),
                                                            Encoder<SampleFilterCriteria>::encode(topic.getCommunicator(),
                                                                                                  criteria)))
{
}

template<typename Key, typename Value, typename SampleFilterCriteria, typename UpdateTag>
template<typename KeyFilter, typename KeyFilterCriteria>
MultiKeyReader<Key, Value, SampleFilterCriteria, UpdateTag>::MultiKeyReader(
        Topic<Key, Value, KeyFilter, KeyFilterCriteria, UpdateTag>& topic,
        std::vector<Key> keys,
        ReaderConfig config) :
    Reader<Key, Value, UpdateTag>(topic.getReader()->create(topic._keyFactory->create(std::move(keys)), config))
{
}

template<typename Key, typename Value, typename SampleFilterCriteria, typename UpdateTag>
MultiKeyReader<Key, Value, SampleFilterCriteria, UpdateTag>::MultiKeyReader(
        MultiKeyReader<Key, Value, SampleFilterCriteria, UpdateTag>&& reader) :
    Reader<Key, Value, UpdateTag>(std::move(reader))
{
}

template<typename Key, typename Value, typename UpdateTag> template<typename KeyFilter, typename KeyFilterCriteria>
KeyReader<Key, Value, void, UpdateTag>::KeyReader(
        Topic<Key, Value, KeyFilter, KeyFilterCriteria, UpdateTag>& topic,
        Key key,
        ReaderConfig config) :
    Reader<Key, Value, UpdateTag>(topic.getReader()->create({ topic._keyFactory->create(std::move(key)) }, config))
{
}

template<typename Key, typename Value, typename UpdateTag>
KeyReader<Key, Value, void, UpdateTag>::KeyReader(KeyReader<Key, Value, void, UpdateTag>&& reader) :
    Reader<Key, Value, UpdateTag>(std::move(reader))
{
}

template<typename Key, typename Value, typename UpdateTag> template<typename KeyFilter, typename KeyFilterCriteria>
MultiKeyReader<Key, Value, void, UpdateTag>::MultiKeyReader(
        Topic<Key, Value, KeyFilter, KeyFilterCriteria, UpdateTag>& topic,
        std::vector<Key> keys,
        ReaderConfig config) :
    Reader<Key, Value, UpdateTag>(topic.getReader()->create(topic._keyFactory->create(std::move(keys)), config))
{
}

template<typename Key, typename Value, typename UpdateTag>
MultiKeyReader<Key, Value, void, UpdateTag>::MultiKeyReader(MultiKeyReader<Key, Value, void, UpdateTag>&& reader) :
    Reader<Key, Value, UpdateTag>(std::move(reader))
{
}

template<typename Key, typename Value, typename SampleFilterCriteria, typename UpdateTag>
template<typename KeyFilter, typename KeyFilterCriteria>
FilteredReader<Key, Value, SampleFilterCriteria, UpdateTag>::FilteredReader(
        Topic<Key, Value, KeyFilter, KeyFilterCriteria, UpdateTag>& topic,
        typename Topic<Key, Value, KeyFilter, KeyFilterCriteria, UpdateTag>::KeyFilterCriteriaType criteria,
        SampleFilterCriteria sampleCriteria,
        ReaderConfig config) :
    Reader<Key, Value, UpdateTag>(topic.getReader()->createFiltered(topic._filterFactory->create(std::move(criteria)),
                                                                    std::move(config),
                                                                    Encoder<SampleFilterCriteria>::encode(topic.getCommunicator(),
                                                                                                          sampleCriteria)))
{
}

template<typename Key, typename Value, typename SampleFilterCriteria, typename UpdateTag>
template<typename KeyFilter, typename KeyFilterCriteria>
FilteredReader<Key, Value, SampleFilterCriteria, UpdateTag>::FilteredReader(
    Topic<Key, Value, KeyFilter, KeyFilterCriteria, UpdateTag>& topic,
    typename Topic<Key, Value, KeyFilter, KeyFilterCriteria, UpdateTag>::KeyFilterCriteriaType criteria,
    ReaderConfig config) :
    Reader<Key, Value, UpdateTag>(topic.getReader()->createFiltered(topic._filterFactory->create(std::move(criteria)),
                                                                    std::move(config)))
{
}

template<typename Key, typename Value, typename SampleFilterCriteria, typename UpdateTag>
FilteredReader<Key, Value, SampleFilterCriteria, UpdateTag>::FilteredReader(
    FilteredReader<Key, Value, SampleFilterCriteria, UpdateTag>&& reader) :
    Reader<Key, Value, UpdateTag>(std::move(reader))
{
}

template<typename Key, typename Value, typename UpdateTag> template<typename KeyFilter, typename KeyFilterCriteria>
FilteredReader<Key, Value, void, UpdateTag>::FilteredReader(
    Topic<Key, Value, KeyFilter, KeyFilterCriteria, UpdateTag>& topic,
    typename Topic<Key, Value, KeyFilter, KeyFilterCriteria, UpdateTag>::KeyFilterCriteriaType criteria,
    ReaderConfig config) :
    Reader<Key, Value, UpdateTag>(topic.getReader()->createFiltered(topic._filterFactory->create(std::move(criteria)), config))
{
}

template<typename Key, typename Value, typename UpdateTag> FilteredReader<Key, Value, void, UpdateTag>::FilteredReader(FilteredReader<Key, Value, void, UpdateTag>&& reader) :
    Reader<Key, Value, UpdateTag>(std::move(reader))
{
}

//
// Writer template implementation
//
template<typename Key, typename Value, typename UpdateTag> Writer<Key, Value, UpdateTag>::~Writer()
{
    if(_impl)
    {
        _impl->destroy();
    }
}

template<typename Key, typename Value, typename UpdateTag> bool
Writer<Key, Value, UpdateTag>::hasReaders() const
{
    return _impl->hasReaders();
}

template<typename Key, typename Value, typename UpdateTag> void
Writer<Key, Value, UpdateTag>::waitForReaders(unsigned int count) const
{
    return _impl->waitForReaders(count);
}

template<typename Key, typename Value, typename UpdateTag> void
Writer<Key, Value, UpdateTag>::waitForNoReaders() const
{
    return _impl->waitForReaders(-1);
}

template<typename Key, typename Value, typename UpdateTag> void
Writer<Key, Value, UpdateTag>::onConnect(std::function<void(std::tuple<std::string, long long int, long long int>)> callback)
{
    _impl->onConnect(std::move(callback));
}

template<typename Key, typename Value, typename UpdateTag> void
Writer<Key, Value, UpdateTag>::onDisconnect(std::function<void(std::tuple<std::string, long long int, long long int>)> callback)
{
    _impl->onDisconnect(std::move(callback));
}

template<typename Key, typename Value, typename SampleFilter, typename SampleFilterCriteria, typename UpdateTag>
template<typename KeyFilter, typename KeyFilterCriteria>
KeyWriter<Key, Value, SampleFilter, SampleFilterCriteria, UpdateTag>::KeyWriter(
        Topic<Key, Value, KeyFilter, KeyFilterCriteria, UpdateTag>& topic,
        Key key,
        WriterConfig config) :
    Writer<Key, Value, UpdateTag>(topic.getWriter()->create({ topic._keyFactory->create(std::move(key)) },
                                                 std::move(config),
                                                 DataStormInternal::FilterFactoryT<
                                                     SampleFilter,
                                                     SampleFilterCriteria,
                                                     DataStormInternal::SampleT<Key, Value>>::createFactory())),
    _tagFactory(topic._tagFactory)
{
}

template<typename Key, typename Value, typename SampleFilter, typename SampleFilterCriteria, typename UpdateTag>
KeyWriter<Key, Value, SampleFilter, SampleFilterCriteria, UpdateTag>::KeyWriter(
        KeyWriter<Key, Value, SampleFilter, SampleFilterCriteria, UpdateTag>&& writer) :
    Writer<Key, Value, UpdateTag>(std::move(writer)),
    _tagFactory(std::move(writer._tagFactory))
{
}

template<typename Key, typename Value, typename SampleFilter, typename SampleFilterCriteria, typename UpdateTag> void
KeyWriter<Key, Value, SampleFilter, SampleFilterCriteria, UpdateTag>::add(const Value& value)
{
   Writer<Key, Value, UpdateTag>::_impl->publish(nullptr,
        std::make_shared<DataStormInternal::SampleT<Key, Value>>(SampleEvent::Add, value));
}

template<typename Key, typename Value, typename SampleFilter, typename SampleFilterCriteria, typename UpdateTag> void
KeyWriter<Key, Value, SampleFilter, SampleFilterCriteria, UpdateTag>::update(const Value& value)
{
    Writer<Key, Value, UpdateTag>::_impl->publish(nullptr,
        std::make_shared<DataStormInternal::SampleT<Key, Value>>(SampleEvent::Update, value));
}

template<typename Key, typename Value, typename SampleFilter, typename SampleFilterCriteria, typename UpdateTag>
template<typename UpdateValue> void
KeyWriter<Key, Value, SampleFilter, SampleFilterCriteria, UpdateTag>::update(const UpdateTag& tag,
                                                                             const UpdateValue& value)
{
    auto encoded = Encoder<UpdateValue>::encode(Writer<Key, Value, UpdateTag>::_impl->getCommunicator(), value);
    Writer<Key, Value, UpdateTag>::_impl->publish(nullptr,
        std::make_shared<DataStormInternal::SampleT<Key, Value>>(encoded, _tagFactory->create(tag)));
}

template<typename Key, typename Value, typename SampleFilter, typename SampleFilterCriteria, typename UpdateTag> void
KeyWriter<Key, Value, SampleFilter, SampleFilterCriteria, UpdateTag>::remove()
{
    Writer<Key, Value, UpdateTag>::_impl->publish(nullptr,
        std::make_shared<DataStormInternal::SampleT<Key, Value>>(SampleEvent::Remove));
}

template<typename Key, typename Value, typename SampleFilter, typename SampleFilterCriteria, typename UpdateTag>
template<typename KeyFilter, typename KeyFilterCriteria>
MultiKeyWriter<Key, Value, SampleFilter, SampleFilterCriteria, UpdateTag>::MultiKeyWriter(
        Topic<Key, Value, KeyFilter, KeyFilterCriteria, UpdateTag>& topic,
        std::vector<Key> keys,
        WriterConfig config) :
    Writer<Key, Value, UpdateTag>(topic.getWriter()->create(topic._keyFactory->create(std::move(keys)),
                                                            std::move(config),
                                                            DataStormInternal::FilterFactoryT<
                                                                SampleFilter,
                                                                SampleFilterCriteria,
                                                                DataStormInternal::SampleT<Key, Value>>::createFactory())),
    _keyFactory(topic._keyFactory),
    _tagFactory(topic._tagFactory)
{
}

template<typename Key, typename Value, typename SampleFilter, typename SampleFilterCriteria, typename UpdateTag>
MultiKeyWriter<Key, Value, SampleFilter, SampleFilterCriteria, UpdateTag>::MultiKeyWriter(
        MultiKeyWriter<Key, Value, SampleFilter, SampleFilterCriteria, UpdateTag>&& writer) :
    Writer<Key, Value, UpdateTag>(std::move(writer)),
    _keyFactory(std::move(writer._keyFactory)),
    _tagFactory(std::move(writer._tagFactory))
{
}

template<typename Key, typename Value, typename SampleFilter, typename SampleFilterCriteria, typename UpdateTag> void
MultiKeyWriter<Key, Value, SampleFilter, SampleFilterCriteria, UpdateTag>::add(const Key& key, const Value& value)
{
    Writer<Key, Value, UpdateTag>::_impl->publish(_keyFactory->create(key),
        std::make_shared<DataStormInternal::SampleT<Key, Value>>(SampleEvent::Add, value));
}

template<typename Key, typename Value, typename SampleFilter, typename SampleFilterCriteria, typename UpdateTag> void
MultiKeyWriter<Key, Value, SampleFilter, SampleFilterCriteria, UpdateTag>::update(const Key& key, const Value& value)
{
    Writer<Key, Value, UpdateTag>::_impl->publish(_keyFactory->create(key),
        std::make_shared<DataStormInternal::SampleT<Key, Value>>(SampleEvent::Update, value));
}

template<typename Key, typename Value, typename SampleFilter, typename SampleFilterCriteria, typename UpdateTag>
template<typename UpdateValue> void
MultiKeyWriter<Key, Value, SampleFilter, SampleFilterCriteria, UpdateTag>::update(const Key& key,
                                                                                  const UpdateTag& tag,
                                                                                  const UpdateValue& value)
{
    auto encoded = Encoder<UpdateValue>::encode(Writer<Key, Value, UpdateTag>::_impl->getCommunicator(), value);
    Writer<Key, Value, UpdateTag>::_impl->publish(_keyFactory->create(key),
        std::make_shared<DataStormInternal::SampleT<Key, Value>>(encoded, _tagFactory->create(tag)));
}

template<typename Key, typename Value, typename SampleFilter, typename SampleFilterCriteria, typename UpdateTag> void
MultiKeyWriter<Key, Value, SampleFilter, SampleFilterCriteria, UpdateTag>::remove(const Key& key)
{
    Writer<Key, Value, UpdateTag>::_impl->publish(_keyFactory->create(key),
        std::make_shared<DataStormInternal::SampleT<Key, Value>>(SampleEvent::Remove));
}

//
// Topic template implementation
//
template<typename Key, typename Value, typename KeyFilter, typename KeyFilterCriteria, typename UpdateTag>
Topic<Key, Value, KeyFilter, KeyFilterCriteria, UpdateTag>::Topic(Node& node, const std::string& name) :
    _name(name),
    _topicFactory(node._factory),
    _keyFactory(DataStormInternal::KeyFactoryT<Key>::createFactory()),
    _filterFactory(DataStormInternal::FilterFactoryT<KeyFilter,
                                                     KeyFilterCriteria,
                                                     DataStormInternal::KeyT<Key>>::createFactory()),
    _tagFactory(DataStormInternal::TagFactoryT<UpdateTag>::createFactory())
{
}

template<typename Key, typename Value, typename KeyFilter, typename KeyFilterCriteria, typename UpdateTag>
Topic<Key, Value, KeyFilter, KeyFilterCriteria, UpdateTag>::Topic(Topic<Key, Value, KeyFilter, KeyFilterCriteria, UpdateTag>&& topic) :
    _topicFactory(topic._topicFactory),
    _keyFactory(std::move(topic._keyFactory)),
    _filterFactory(std::move(topic._filterFactory)),
    _tagFactory(std::move(topic._tagFactory)),
    _reader(std::move(topic._reader)),
    _writer(std::move(topic._writer))
{
}

template<typename Key, typename Value, typename KeyFilter, typename KeyFilterCriteria, typename UpdateTag>
Topic<Key, Value, KeyFilter, KeyFilterCriteria, UpdateTag>::~Topic()
{
    std::lock_guard<std::mutex> lock(_mutex);
    if(_reader)
    {
        _reader->destroy();
    }
    if(_writer)
    {
        _writer->destroy();
    }
}

template<typename Key, typename Value, typename KeyFilter, typename KeyFilterCriteria, typename UpdateTag> bool
Topic<Key, Value, KeyFilter, KeyFilterCriteria, UpdateTag>::hasWriters() const
{
    return getReader()->hasWriters();
}

template<typename Key, typename Value, typename KeyFilter, typename KeyFilterCriteria, typename UpdateTag> void
Topic<Key, Value, KeyFilter, KeyFilterCriteria, UpdateTag>::waitForWriters(unsigned int count) const
{
    getReader()->waitForWriters(count);
}

template<typename Key, typename Value, typename KeyFilter, typename KeyFilterCriteria, typename UpdateTag> void
Topic<Key, Value, KeyFilter, KeyFilterCriteria, UpdateTag>::waitForNoWriters() const
{
    getReader()->waitForWriters(-1);
}

template<typename Key, typename Value, typename KeyFilter, typename KeyFilterCriteria, typename UpdateTag> void
Topic<Key, Value, KeyFilter, KeyFilterCriteria, UpdateTag>::setReaderDefaultConfig(ReaderConfig config)
{
    getReader()->setDefaultConfig(std::move(config));
}

template<typename Key, typename Value, typename KeyFilter, typename KeyFilterCriteria, typename UpdateTag> bool
Topic<Key, Value, KeyFilter, KeyFilterCriteria, UpdateTag>::hasReaders() const
{
    return getWriter()->hasReaders();
}

template<typename Key, typename Value, typename KeyFilter, typename KeyFilterCriteria, typename UpdateTag> void
Topic<Key, Value, KeyFilter, KeyFilterCriteria, UpdateTag>::waitForReaders(unsigned int count) const
{
    getWriter()->waitForReaders(count);
}

template<typename Key, typename Value, typename KeyFilter, typename KeyFilterCriteria, typename UpdateTag> void
Topic<Key, Value, KeyFilter, KeyFilterCriteria, UpdateTag>::waitForNoReaders() const
{
    getWriter()->waitForReaders(-1);
}

template<typename Key, typename Value, typename KeyFilter, typename KeyFilterCriteria, typename UpdateTag> void
Topic<Key, Value, KeyFilter, KeyFilterCriteria, UpdateTag>::setWriterDefaultConfig(WriterConfig config)
{
    getWriter()->setDefaultConfig(std::move(config));
}

template<typename Key, typename Value, typename KeyFilter, typename KeyFilterCriteria, typename UpdateTag>
template<typename UpdateValue> void
Topic<Key, Value, KeyFilter, KeyFilterCriteria, UpdateTag>::setUpdater(const UpdateTag& tag,
                                                                       std::function<void (Value&, UpdateValue)> updater)
{
    std::lock_guard<std::mutex> lock(_mutex);
    auto tagI = _tagFactory->create(std::move(tag));
    auto updaterImpl = [updater](const std::shared_ptr<DataStormInternal::Sample>& previous,
                                 const std::shared_ptr<DataStormInternal::Sample>& next,
                                 const std::shared_ptr<Ice::Communicator>& communicator)
    {
        Value value;
        if(previous)
        {
            value = Cloner<Value>::clone(std::static_pointer_cast<DataStormInternal::SampleT<Key, Value>>(previous)->getValue());
        }
        updater(value, Decoder<UpdateValue>::decode(communicator, next->getEncodedValue()));
        std::static_pointer_cast<DataStormInternal::SampleT<Key, Value>>(next)->setValue(std::move(value));
    };

    if(_reader && !_writer)
    {
        _reader->setUpdater(tagI, updaterImpl);
    }
    else if(_writer && !_reader)
    {
        _writer->setUpdater(tagI, updaterImpl);
    }
    else if(_reader && _writer)
    {
        _reader->setUpdater(tagI, updaterImpl);
        _writer->setUpdater(tagI, updaterImpl);
    }
    else
    {
        _updaters[tagI] = updaterImpl;
    }
}

template<typename Key, typename Value, typename KeyFilter, typename KeyFilterCriteria, typename UpdateTag>
std::shared_ptr<DataStormInternal::TopicReader>
Topic<Key, Value, KeyFilter, KeyFilterCriteria, UpdateTag>::getReader() const
{
    std::lock_guard<std::mutex> lock(_mutex);
    if(!_reader)
    {
        _reader = _topicFactory->createTopicReader(_name,
                                                   _keyFactory,
                                                   _filterFactory,
                                                   _tagFactory,
                                                   std::make_shared<DataStormInternal::SampleFactoryT<Key, Value>>());
        _reader->setUpdaters(_writer ? _writer->getUpdaters() : _updaters);
        _updaters.clear();
    }
    return _reader;
}

template<typename Key, typename Value, typename KeyFilter, typename KeyFilterCriteria, typename UpdateTag>
std::shared_ptr<DataStormInternal::TopicWriter>
Topic<Key, Value, KeyFilter, KeyFilterCriteria, UpdateTag>::getWriter() const
{
    std::lock_guard<std::mutex> lock(_mutex);
    if(!_writer)
    {
        _writer = _topicFactory->createTopicWriter(_name, _keyFactory, _filterFactory, _tagFactory, nullptr);
        _writer->setUpdaters(_reader ? _reader->getUpdaters() : _updaters);
        _updaters.clear();
    }
    return _writer;
}

template<typename Key, typename Value, typename KeyFilter, typename KeyFilterCriteria, typename UpdateTag>
std::shared_ptr<Ice::Communicator>
Topic<Key, Value, KeyFilter, KeyFilterCriteria, UpdateTag>::getCommunicator() const
{
    return _topicFactory->getCommunicator();
}

}